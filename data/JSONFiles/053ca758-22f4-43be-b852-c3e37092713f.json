[
    {
        "id": "9221d631-ebb3-43cd-871f-99b1cbe3c99a",
        "title": "",
        "chunk_text": "On the Importance of Error Mitigation for Quantum Computation Dorit Aharonov∗1,2, Ori Alberton1, Itai Arad1,3, Yosi Atia1, Eyal Bairey1, Zvika Brakerski1,4, Itsik Cohen1, Omri Golan†1, Ilya Gurwich1, Oded Kenneth1,5, Eyal Leviatan1, Netanel H.",
        "metadata": {
            "author": "",
            "keywords": [
                "Eyal",
                "Ori",
                "Itai",
                "Yosi",
                "Zvika",
                "Itsik",
                "Ilya",
                "Oded",
                "Aharonov",
                "Omri"
            ]
        }
    },
    {
        "id": "eda40d2f-e2c2-49ca-a900-97ccc5cfb30e",
        "title": "",
        "chunk_text": "Lindner1,5, Ron Aharon Melcer1, Adiel Meyer1, Gili Schul1, and Maor Shutman1 1Qedma Quantum Computing, Tel Aviv, Israel 2The Benin School of Computer Science and Engineering, Hebrew University, Jerusalem, Israel 3Centre for Quantum Technologies, National University of Singapore, Singapore 4Faculty of Mathematics and Computer Science, Weizmann Institute of Science, Israel 5Department of Physics, Technion, Haifa, Israel Abstract Quantum error mitigation (EM) is a family of hybrid quantum-classical methods for eliminating or reducing the effect of noise and decoherence on quantum algorithms run on quantum hardware, without applying quantum error correction (EC).",
        "metadata": {
            "author": "",
            "keywords": [
                "Israel",
                "Quantum",
                "Science",
                "Singapore",
                "Computer",
                "University",
                "Adiel",
                "Gili",
                "Jerusalem",
                "Technion"
            ]
        }
    },
    {
        "id": "5a164fc2-ed22-46d5-aa87-b570e3d51e25",
        "title": "",
        "chunk_text": "While EM has many benefits compared to EC, specifically that it requires no (or little) qubit overhead, this benefit comes with a painful price: EM seems to necessitate an overhead in quantum run time which grows as a (mild) exponent [1–4]. Accordingly, recent results show that EM alone cannot enable exponential quantum advantages (QAs), for an average variant of the expectation value estimation problem [5]. These works raised concerns regarding the role of EM in the road map towards QAs.",
        "metadata": {
            "author": "",
            "keywords": [
                "mild",
                "exponent",
                "overhead",
                "specifically",
                "qubit",
                "price",
                "quantum",
                "QAs",
                "compared",
                "requires"
            ]
        }
    },
    {
        "id": "10e5f56e-6cbc-4a16-af9e-5ed4cac8cde2",
        "title": "",
        "chunk_text": "We aim to demystify the discussion, and provide a clear picture of the role of EM in achieving QAs, both in the near and long term. We first propose a clear distinction between finite QA and asymptotic QA, which is crucial to the understanding of the question, and present the notion of circuit volume boost, which we claim is an adequate way to quantify the benefits of EM. Using these notions we can argue straightforwardly that EM is expected to have a significant role in achieving QAs.",
        "metadata": {
            "author": "",
            "keywords": [
                "QAs",
                "clear",
                "achieving",
                "discussion",
                "term",
                "aim",
                "demystify",
                "provide",
                "picture",
                "long"
            ]
        }
    },
    {
        "id": "51ef217e-541d-4a99-9989-75ed5e2f8892",
        "title": "",
        "chunk_text": "Specifically, that EM is likely to be the first error reduction method for useful finite QAs, before EC; that the first such QAs are expected to be achieved using EM in the very near future; and that EM is expected to maintain its important role in quantum computation even when EC will be routinely used – for as long as high-quality qubits remain a scarce resource. Contents 1 Introduction 1 1.1 Error correction (EC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
        "metadata": {
            "author": "",
            "keywords": [
                "expected",
                "Specifically",
                "QAs",
                "error",
                "Introduction",
                "future",
                "resource",
                "reduction",
                "method",
                "finite"
            ]
        }
    },
    {
        "id": "8ed922fe-e14f-4146-8654-5e3edaf23a45",
        "title": "",
        "chunk_text": "1 1.2 Error mitigation (EM) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.3 This paper, in a nutshell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.4 Overview of key points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2 Asymptotic vs. finite quantum advantage (QA) 6 2.1 Asymptotic QA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.2 Finite QA . . . . . . . .",
        "metadata": {
            "author": "",
            "keywords": [
                "Error",
                "mitigation",
                "Asymptotic",
                "finite",
                "Overview",
                "paper",
                "nutshell",
                "points",
                "advantage",
                "key"
            ]
        }
    },
    {
        "id": "b52f1f40-71be-4291-af80-52fb20f0d2f8",
        "title": "",
        "chunk_text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.3 Scalable QA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.4 Asymptotic QA vs. Finite QA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.5 Quantifying resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
        "metadata": {
            "author": "",
            "keywords": [
                "Scalable",
                "Asymptotic",
                "Quantifying",
                "Finite",
                "resources"
            ]
        }
    },
    {
        "id": "03599406-535e-466f-a174-ba9fb00d6610",
        "title": "",
        "chunk_text": "9 ∗dorit.aharonov@qedma.com †omri.golan@qedma.com arXiv:2503.17243v1 [quant-ph] 21 Mar 2025 1 INTRODUCTION 3 Expectation value estimation 10 3.1 Problem statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 3.2 Active circuit volume . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 4 Evidence against asymptotic QA with EM 12 4.1 Evidence for exponential sampling overhead of EM . . . . . . . . . . . . . . . . . . . . . .",
        "metadata": {
            "author": "",
            "keywords": [
                "Mar",
                "INTRODUCTION",
                "Expectation",
                "Problem",
                "qedma.com",
                "dorit.aharonov",
                "omri.golan",
                "quant-ph",
                "arXiv",
                "estimation"
            ]
        }
    },
    {
        "id": "02d112a2-388d-49f2-9fc1-a248ec90cb4f",
        "title": "",
        "chunk_text": "12 4.2 Towards general exponential lower bounds on the sampling overhead . . . . . . . . . . . . 13 4.3 EM with exponential overheads cannot enable exponential asymptotic QA . . . . . . . . . 14 4.4 No-go for exponential asymptotic QA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 5 Useful finite QAs expected in the near future using EM 16 5.1 Circuit Volume Boosts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
        "metadata": {
            "author": "",
            "keywords": [
                "exponential",
                "general",
                "lower",
                "bounds",
                "sampling",
                "asymptotic",
                "No-go",
                "Circuit",
                "Boosts",
                "Volume"
            ]
        }
    },
    {
        "id": "abba9837-57e7-4b7d-8d5a-6b128dab8d00",
        "title": "",
        "chunk_text": "17 5.2 Predictions for finite QAs enabled using EM alone . . . . . . . . . . . . . . . . . . . . . . 19 6 EM in the era of fault tolerant EC 23 6.1 The fault tolerance misconception: Why additional error reduction is needed even when fault tolerant EC is available . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 6.2 Logical EM: Combining EM with EC to provide further circuit volume boosts . . . . . . 24 6.3 Concluding remarks about logical EM . . . . . . . . . . . . . . . .",
        "metadata": {
            "author": "",
            "keywords": [
                "Predictions",
                "finite",
                "QAs",
                "enabled",
                "fault",
                "Logical",
                "tolerant",
                "Combining",
                "Concluding",
                "misconception"
            ]
        }
    },
    {
        "id": "f0eece33-100b-4470-8818-690f4576bded",
        "title": "",
        "chunk_text": ". . . . . . . . . . . . . 27 7 Summary and forecast: QA timeline 27 1 Introduction 1.1 Error correction (EC) The necessity of protecting quantum computations from noise had been realized already close to three decades ago, soon after the remarkable theoretical discoveries indicating a potential for exponential algorithmic speedups (or quantum advantages, QAs) over classical computing devices [6, 7], including Shor’s algorithm [8].",
        "metadata": {
            "author": "",
            "keywords": [
                "Introduction",
                "quantum",
                "Summary",
                "Error",
                "QAs",
                "Shor",
                "forecast",
                "timeline",
                "correction",
                "ago"
            ]
        }
    },
    {
        "id": "610f0195-d040-48d1-a0e6-cc86188d09e4",
        "title": "",
        "chunk_text": "The no less remarkable discovery of quantum error correction (EC) [9, 10] and the follow-up proofs of threshold theorems showing that EC can be made fault-tolerant [11–14], laid the foundations for the approach taken today to handle noise: large scale quantum computers (or quantum processing units, QPUs) are to be protected from the detrimental effect of noise by redundantly encoding computational logical qubits into physical qubits, and performing fault-tolerant EC, periodically measuring and correcting errors.",
        "metadata": {
            "author": "",
            "keywords": [
                "quantum",
                "QPUs",
                "fault-tolerant",
                "noise",
                "qubits",
                "correction",
                "laid",
                "large",
                "computers",
                "units"
            ]
        }
    },
    {
        "id": "f7914c32-c7e2-4407-9650-2ae2afd76c72",
        "title": "",
        "chunk_text": "Fault-tolerant EC has since become a lively active field on its own, and most quantum hardware companies have adopted this path as the main approach in their roadmap, to handle noise in future large scale QPUs [15–20]. However, the EC approach suffers from several severe practical drawbacks. First, it requires very large overheads in qubit numbers, due to the redundant encoding of physical qubits into logical qubits, as well additional qubits needed to periodically measure error syndromes.",
        "metadata": {
            "author": "",
            "keywords": [
                "Fault-tolerant",
                "roadmap",
                "QPUs",
                "approach",
                "lively",
                "active",
                "field",
                "quantum",
                "hardware",
                "companies"
            ]
        }
    },
    {
        "id": "103e9b4e-97ce-4b25-b891-c25792d7f664",
        "title": "",
        "chunk_text": "The second drawback is of course the requirement for extremely high quality qubits; fault tolerance requires that the gates applied on the qubits be of fidelity better than a certain threshold, the “fault tolerance threshold”. EC is only beneficial if the infidelity is below that threshold. Moreover, the closer to the threshold the actual infidelity is, the larger the qubit overhead required in order to achieve the same effective (logical) error rate.",
        "metadata": {
            "author": "",
            "keywords": [
                "fault",
                "tolerance",
                "threshold",
                "qubits",
                "drawback",
                "requirement",
                "extremely",
                "high",
                "quality",
                "requires"
            ]
        }
    },
    {
        "id": "69c37ff6-ad09-4780-b63f-87de1385a66a",
        "title": "",
        "chunk_text": "This importantly implies that even when the infidelity is below the quantum fault tolerance threshold, the noise still limits the size of the quantum computation. By far the most important leading candidate for a quantum error correcting code to be used on fault tolerant quantum devices, had been, for a long time, the surface code [21], due to its high threshold value [22].",
        "metadata": {
            "author": "",
            "keywords": [
                "quantum",
                "fault",
                "threshold",
                "computation",
                "importantly",
                "implies",
                "infidelity",
                "tolerance",
                "noise",
                "limits"
            ]
        }
    },
    {
        "id": "ce65ce92-7180-4d3b-a6a7-824b3aaa261a",
        "title": "",
        "chunk_text": "However, due to the large qubit overhead it requires, recently the interest of the industry had shifted to other codes, and in particular to quantum low-density parity check (qLDPC) codes [23–25], as well as concatenated codes [26, 27]. The past year has seen tremendous progress on the experimental side of various fault tolerance components [28–33].",
        "metadata": {
            "author": "",
            "keywords": [
                "codes",
                "qLDPC",
                "due",
                "requires",
                "recently",
                "check",
                "large",
                "qubit",
                "overhead",
                "interest"
            ]
        }
    },
    {
        "id": "98e07011-bff7-4f02-ab27-60cd6fc8d7aa",
        "title": "",
        "chunk_text": "However, it is still unclear when quantum computers with 1 1 INTRODUCTION sufficiently many high quality logical qubits will be available to enable the first useful QAs using EC alone.",
        "metadata": {
            "author": "",
            "keywords": [
                "INTRODUCTION",
                "unclear",
                "quantum",
                "computers",
                "sufficiently",
                "high",
                "quality",
                "logical",
                "qubits",
                "enable"
            ]
        }
    },
    {
        "id": "f6a78bbb-af40-4074-81bb-a46abd111665",
        "title": "",
        "chunk_text": "By useful QA we mean any computation performed by a QPU faster or better than possible by classical computers, and whose output is of interest outside of the question of whether it was achieved by a QPU or by some other computational means.1 According to the public roadmaps of both IBM [16] and Quantinuum [18], for example, achieving the first useful QAs with EC is a matter of at least five years.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "IBM",
                "Quantinuum",
                "computers",
                "computational",
                "achieving",
                "years",
                "computation",
                "performed",
                "faster"
            ]
        }
    },
    {
        "id": "9ca8a98b-35a6-4fec-afca-29b84ba49cb2",
        "title": "",
        "chunk_text": "1.2 Error mitigation (EM) In light of these hurdles, and the long anticipated time until useful QA with EC, side by side with the immense effort and many successes in improving fault tolerant constructions and reducing their requirements, another approach had been developed - a family of protocols which goes by the name of quantum error mitigation (EM) [41].",
        "metadata": {
            "author": "",
            "keywords": [
                "mitigation",
                "Error",
                "side",
                "hurdles",
                "requirements",
                "developed",
                "light",
                "long",
                "anticipated",
                "time"
            ]
        }
    },
    {
        "id": "2e295183-bab5-468b-983e-04efa22f30c6",
        "title": "",
        "chunk_text": "Such EM protocols replace the execution of a given target circuit with multiple noisy circuit executions; the results of which are post-processed to provide an estimate for the error-free output of the target circuit. The first EM protocols, based on quasi-probability (QP) distributions and zero-noise extrapolation (ZNE) were developed in [42–44] and followed by a plethora of additional protocols and extensions [41, 45–47]. The advantages of EM methods over EC are threefold. 1.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "target",
                "protocols",
                "ZNE",
                "execution",
                "executions",
                "replace",
                "multiple",
                "noisy",
                "results"
            ]
        }
    },
    {
        "id": "c6d3b9cf-c580-4e30-bf25-7addf04b620d",
        "title": "",
        "chunk_text": "Unlike EC, the EM approach does not require adaptive operations.2 Thus the requirements on the hardware are significantly relaxed. This lack of adaptive operations is the theoretically defining feature of EM [1–4]. 2. EM methods entail no (or little) overhead in qubit number.",
        "metadata": {
            "author": "",
            "keywords": [
                "Unlike",
                "relaxed",
                "adaptive",
                "approach",
                "require",
                "requirements",
                "hardware",
                "significantly",
                "lack",
                "operations"
            ]
        }
    },
    {
        "id": "2efe2802-5ef1-4ace-89b9-39d5cd553df1",
        "title": "",
        "chunk_text": "This is critical, given the fact that increasing the number of high quality qubits has proven to be a steady but unfortunately slow process, at least in the currently leading publicly available hardware platforms of superconducting qubits and trapped ions [16, 18]. Qubit numbers may be larger, though still limited, in upcoming neutral atom platforms [17]. 3. Last but not least, EM methods do not require the error rate to be below any threshold! They work with any infidelity.",
        "metadata": {
            "author": "",
            "keywords": [
                "critical",
                "process",
                "ions",
                "platforms",
                "qubits",
                "fact",
                "increasing",
                "high",
                "quality",
                "proven"
            ]
        }
    },
    {
        "id": "e161e23e-e9e9-4741-8b60-6aa40a30cd72",
        "title": "",
        "chunk_text": "These advantages make EM applicable on current quantum processors. Indeed, EM protocols are now being routinely used in essentially all large scale quantum computing experiments, showcasing impressive achievements and demonstrating the ability of those methods to bring current quantum processors much closer to QA [48–55].",
        "metadata": {
            "author": "",
            "keywords": [
                "quantum",
                "current",
                "processors",
                "advantages",
                "make",
                "applicable",
                "experiments",
                "showcasing",
                "protocols",
                "routinely"
            ]
        }
    },
    {
        "id": "ca53854c-afcf-463c-a722-776ed315ab76",
        "title": "",
        "chunk_text": "Importantly, already from the first EM protocols, it was clear that these protocols come with a painful price: they exhibit a sampling overhead that grows like a mild exponent with the size of the computation. This exponential price of EM raises important questions: Is EM worth the effort and the time overhead? Is it a viable approach for addressing quantum noise on the way to achieving useful QAs? And very importantly, what would its role be when EC becomes available for end-users?",
        "metadata": {
            "author": "",
            "keywords": [
                "protocols",
                "computation",
                "price",
                "overhead",
                "Importantly",
                "clear",
                "painful",
                "exhibit",
                "sampling",
                "grows"
            ]
        }
    },
    {
        "id": "eb38d962-c9d2-436f-b175-59c3705cbb19",
        "title": "",
        "chunk_text": "In particular, concerns were recently raised following several papers [1–4] that highlighted exponential lower bounds on the sampling overhead of EM. Importantly, a recent strong result by [5] managed to rule out the possibility that EM can provide exponential QA for a certain computational problem (we discuss the results of those papers and their implications in Sec. 4). In light of all this, what is the role of EM in the future of quantum computation?",
        "metadata": {
            "author": "",
            "keywords": [
                "concerns",
                "papers",
                "exponential",
                "recently",
                "raised",
                "highlighted",
                "lower",
                "bounds",
                "sampling",
                "overhead"
            ]
        }
    },
    {
        "id": "8292f4d5-c7d6-42c7-9fc0-4677e6e03f02",
        "title": "",
        "chunk_text": "Perhaps it should be considered as a temporary method, interesting for investigations but to be abandoned very soon when EC takes over? 1QAs have already been argued in several experiments [28, 34–39], including random circuit sampling (RCS) experiments; we will mention those in Section 2. As remarkable as these achievements are, they do not belong to this class of useful QAs, since their output is in general not useful, for any purpose other than demonstrating QA (though Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "method",
                "interesting",
                "RCS",
                "experiments",
                "considered",
                "temporary",
                "investigations",
                "abandoned",
                "Section",
                "Ref"
            ]
        }
    },
    {
        "id": "77c36192-3ebc-4d64-9b0f-eeef7d78c592",
        "title": "",
        "chunk_text": "[40] suggested using RCS to generate certifiable randomness). 2Namely, mid-circuit measurements, followed by real-time classical processing of measurement results, which are in turn followed by unitary gates conditioned on the classical processing output.",
        "metadata": {
            "author": "",
            "keywords": [
                "RCS",
                "suggested",
                "randomness",
                "generate",
                "certifiable",
                "classical",
                "processing",
                "mid-circuit",
                "results",
                "output"
            ]
        }
    },
    {
        "id": "6a2d3139-bbe1-43eb-8f0d-cfbb98803c71",
        "title": "",
        "chunk_text": "2 1 INTRODUCTION 1.3 This paper, in a nutshell The question regarding the role of EM in the evolution of quantum computation is crucial for the clarification of the path that the quantum eco-system will take as it moves forward towards algorithmic QAs. In this manuscript, we aim to remove some of the misconceptions in the public discussion regarding this question, and by that, clarify the role of EM in this roadmap towards algorithmic QAs.",
        "metadata": {
            "author": "",
            "keywords": [
                "INTRODUCTION",
                "quantum",
                "QAs",
                "role",
                "algorithmic",
                "question",
                "paper",
                "nutshell",
                "evolution",
                "computation"
            ]
        }
    },
    {
        "id": "3f4726fa-d148-4bc7-8b37-69177a905ab9",
        "title": "",
        "chunk_text": "The main message of this paper can be summarized as follows: There are two different types of QA which should not be confused: asymptotic QA, which is a mathematical notion, and finite QA, which is a practical notion. While asymptotic QA is probably indeed not achievable by EM alone, EM is expected to provide dramatic finite QA in the near future, and in fact be the first error reduction approach to provide useful QA, before this will be achieved by EC.",
        "metadata": {
            "author": "",
            "keywords": [
                "notion",
                "asymptotic",
                "finite",
                "confused",
                "main",
                "message",
                "paper",
                "summarized",
                "types",
                "mathematical"
            ]
        }
    },
    {
        "id": "b503747e-e023-46da-929c-f54e237a0afe",
        "title": "",
        "chunk_text": "Furthermore, even when fault-tolerant EC becomes available, it is a misconception that this will completely resolve the problem of noise in quantum computation. Since quantum computers are expected to have a limited number of high-fidelity qubits in the foreseeable future, we expect severe limitations on the quantum circuit volumes available even when fault tolerant EC becomes available.",
        "metadata": {
            "author": "",
            "keywords": [
                "computation",
                "quantum",
                "fault-tolerant",
                "misconception",
                "completely",
                "resolve",
                "problem",
                "noise",
                "future",
                "computers"
            ]
        }
    },
    {
        "id": "a5328be2-eec8-4d8f-9005-336ab26f0fd1",
        "title": "",
        "chunk_text": "At that time, EM combined with EC would provide a much more effective error reduction solution, leading to circuit volumes that are orders of magnitude larger than those available by EC alone. Thus, EM is here to stay, and is expected to play a crucial role in all important milestones of the quantum ecosystem in the near and far future. The paper follows the above sequence of claims and provides details behind each of the key points.",
        "metadata": {
            "author": "",
            "keywords": [
                "time",
                "solution",
                "leading",
                "combined",
                "effective",
                "error",
                "reduction",
                "circuit",
                "volumes",
                "orders"
            ]
        }
    },
    {
        "id": "29ff92d2-9566-4c5a-ad36-423b3c1d9870",
        "title": "",
        "chunk_text": "Section 1.4 provides a more detailed overview of the flow of the paper. We attempt to keep the discussion simple, and gloss over some details, referring the reader to other resources where these details appear. Table 1 provides an overview of different methods for handling errors in quantum computation, along with the main take-away messages we propose for each method. EM, EC, and logical error mitigation (LEM) are discussed throughout the paper, as detailed below.",
        "metadata": {
            "author": "",
            "keywords": [
                "Section",
                "paper",
                "overview",
                "flow",
                "details",
                "detailed",
                "LEM",
                "simple",
                "referring",
                "Table"
            ]
        }
    },
    {
        "id": "f830541c-4abf-4520-8ddb-171dec959ab3",
        "title": "",
        "chunk_text": "We do not discuss error suppression (ES) except in this table, and assume throughout the paper that ‘bare’, or ‘noisy’, quantum circuit execution already includes the best available ES methods. 1.4 Overview of key points ■Asymptotic vs. finite Quantum advantages Our starting point (Sec. 2) is a distinction, that we believe is too often overlooked, between two notions of QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "bare’",
                "noisy’",
                "Sec",
                "suppression",
                "table",
                "methods",
                "quantum",
                "Overview",
                "Asymptotic",
                "discuss"
            ]
        }
    },
    {
        "id": "fecfc28a-a7cf-4732-b38d-4031cc6c15fc",
        "title": "",
        "chunk_text": "One is an asymptotic notion, where the most famous example, perhaps, is Shor’s factoring algorithm that, as far as we know, performs exponentially better than any classical factoring algorithm, when considering the asymptotic cost. The other is finite QA, which refers to a concrete experiment where a QPU computes “much faster” than a classical computer.",
        "metadata": {
            "author": "",
            "keywords": [
                "Shor",
                "factoring",
                "algorithm",
                "asymptotic",
                "notion",
                "performs",
                "cost",
                "classical",
                "famous",
                "exponentially"
            ]
        }
    },
    {
        "id": "b90cf606-4aed-4b4c-bdf5-b8f7be5e1be6",
        "title": "",
        "chunk_text": "Ideally, the experiment can be repeated with larger and larger settings to establish a scalable behavior, where the QA is expected to strengthen as the problem size grows. We discuss some of the subtleties involved in defining finite QA, such as the proper way to define what is meant by “much faster”, i.e., what is the proper way to quantify the cost of the computation.",
        "metadata": {
            "author": "",
            "keywords": [
                "larger",
                "Ideally",
                "behavior",
                "grows",
                "proper",
                "experiment",
                "repeated",
                "settings",
                "establish",
                "scalable"
            ]
        }
    },
    {
        "id": "7f5e51ec-446c-4da4-ab4e-5415805e2211",
        "title": "",
        "chunk_text": "■The expectation value estimation problem, and definition of active volume We next present the computational problem on which we focus our discussion of the above notions of QA: expectation value estimation (EVE), in which for a given circuit C and an observable O, one is required to estimate the expectation value of O in the state obtained by applying C to the all zero input state, with a prescribed accuracy.",
        "metadata": {
            "author": "",
            "keywords": [
                "expectation",
                "EVE",
                "estimation",
                "problem",
                "state",
                "accuracy",
                "definition",
                "active",
                "volume",
                "present"
            ]
        }
    },
    {
        "id": "adb11e89-22cd-4818-91dc-b380cce62a71",
        "title": "",
        "chunk_text": "EVE is one of the most basic problems in physics and has a variety of applications within the field of quantum algorithms. Furthermore, EVE is particularly appropriate for the discussion 3Realistically, dissipative dynamics is due to coherent interaction with an environment.",
        "metadata": {
            "author": "",
            "keywords": [
                "EVE",
                "algorithms",
                "basic",
                "problems",
                "physics",
                "variety",
                "applications",
                "field",
                "quantum",
                "discussion"
            ]
        }
    },
    {
        "id": "5bbf7ae2-7ebc-44de-8277-65fc5a7dfcde",
        "title": "",
        "chunk_text": "The distinction we make between ‘coherent’ and ‘dissipative’ errors then depends on the dynamical time scales of the environment relative to the time scales for implementing quantum gates: interaction with a ‘slow’ (‘fast’) environment manifests as ‘coherent’ (‘dissipative’).",
        "metadata": {
            "author": "",
            "keywords": [
                "coherent’",
                "dissipative’",
                "slow’",
                "fast’",
                "time",
                "scales",
                "environment",
                "gates",
                "interaction",
                "distinction"
            ]
        }
    },
    {
        "id": "3a23be2d-e1d5-45bb-aa8a-2b02677f8ba4",
        "title": "",
        "chunk_text": "4Beyond the main resources stated, we note that EM can actually benefit from extra qubits via e.g., parallelization and coherent operations on multiple copies of the noisy computation, and EC does actually require a QPU time overhead, since logical operations are composed of multiple physical gate layers.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "stated",
                "parallelization",
                "computation",
                "overhead",
                "layers",
                "operations",
                "multiple",
                "main",
                "resources"
            ]
        }
    },
    {
        "id": "51b76de8-3213-46aa-b7a2-f4f725c98597",
        "title": "",
        "chunk_text": "5For EM and LEM, we assume a negligible mitigation bias b ≪ϵ, and the range 1 −10 depends the details of the EM method used, and on the allowed shot overhead (fixing the allowed shot number leads to a logarithmic dependence on ϵ, see Sec. 5.1). 3 1 INTRODUCTION Table 1: Overview of different approaches for dealing with errors in quantum computation.",
        "metadata": {
            "author": "",
            "keywords": [
                "allowed",
                "LEM",
                "Sec.",
                "shot",
                "range",
                "depends",
                "overhead",
                "fixing",
                "assume",
                "negligible"
            ]
        }
    },
    {
        "id": "4c5934a3-73e0-49f7-b16b-08dba69544ca",
        "title": "",
        "chunk_text": "ES is not further discussed in this paper, and we assume throughout that the best available ES methods have been incorporated into the ‘bare’, or ‘noisy’ circuit execution. EM is described in Sec. 4-5, while EC and LEM are discussed in Sec. 6. Error Suppression (ES) Error Mitigation (EM) Error Correction (EC) Logical EM (LEM) Relation Always done. On top of ES, instead of EC. On top of ES, instead of EM. On top of ES and EC.",
        "metadata": {
            "author": "",
            "keywords": [
                "Error",
                "Sec",
                "bare’",
                "top",
                "LEM",
                "paper",
                "noisy’",
                "execution",
                "discussed",
                "assume"
            ]
        }
    },
    {
        "id": "60e9d0e2-f2dd-403b-9f47-7cb07891ed65",
        "title": "",
        "chunk_text": "Main idea Cancel coherent errors (directly, or between layers or shots).3 Run multiple noisy computations and post-process. Encode qubits redundantly, measure and invert errors in real time. Perform EC and mitigate remaining logical errors. Main resource Essentially free. QPU time.4 Qubits.4 Trade QPU time for qubits. Examples Gate calibration, Pauli twirling, dynamical decoupling. Zero Noise Extrapolation (ZNE), Quasi Probability (QP), Clifford Data Regression (CDR).",
        "metadata": {
            "author": "",
            "keywords": [
                "Run",
                "Cancel",
                "directly",
                "shots",
                "post-process",
                "errors",
                "Main",
                "QPU",
                "idea",
                "coherent"
            ]
        }
    },
    {
        "id": "725cd9b2-a88f-48c4-bcd8-bf6e5879fcdf",
        "title": "",
        "chunk_text": "Steane, Surface, quantum Low Density Parity Check (qLDPC), concatenation. External LEM, Error correction with post-selection (EC+PS), Syndrome-aware LEM. Maximal circuit volume Vbare := VES ∼ϵ/γ, for allowed inaccuracy ϵ and (un-suppressed) gate infidelity γ. VEM ∼(1 −10)/γ, independent of ϵ.5 VEC ∼ϵ/γ′, for allowed inaccuracy ϵ and logical gate infidelity γ′.",
        "metadata": {
            "author": "",
            "keywords": [
                "Surface",
                "Check",
                "Low",
                "Density",
                "Parity",
                "LEM",
                "Steane",
                "qLDPC",
                "concatenation",
                "quantum"
            ]
        }
    },
    {
        "id": "e8b5546e-5543-4424-b112-9670a4b87901",
        "title": "",
        "chunk_text": "VLEM ∼(1 −10)/γ′, independent of ϵ.5 Take-away message Should be done as much as possible, but fundamentally cannot handle dissipation,3 and therefore limited to small volume. Volume boosted by a factor ∼(1 −10)/ϵ over ES. If physical qubit number is limited, tension between logical accuracy (or depth) and width: Higher accuracy requires smaller γ′, which requires more physical qubits per logical qubit, leaving less logical qubits. Break EM volume barrier with EC.",
        "metadata": {
            "author": "",
            "keywords": [
                "VLEM",
                "Take-away",
                "volume",
                "independent",
                "handle",
                "logical",
                "message",
                "fundamentally",
                "small",
                "limited"
            ]
        }
    },
    {
        "id": "a96487ba-5ca9-46f0-9856-73bc139a3c15",
        "title": "",
        "chunk_text": "Ease accuracy-width tension in EC. Volume boosted by a factor ∼(1 −10)/ϵ over EC. Volumes anticipated based on Hardware roadmaps Not indicated. V ∼103 within 2025 [16, 18]. V ∼104 by 2027-2028 [16, 18]. Larger volumes not anticipated with EM [16, 18]. V ∼103 −104 within 2026 [17]. V ∼104 −109 within 2029 [18]. V ∼108 within 2029 [16]. Not indicated. of EM. We define EVE in Sec. 3, together with the notion of active volume – the relevant notion of quantum circuit volume within the context of EVE.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ease",
                "Volume",
                "EVE",
                "accuracy-width",
                "tension",
                "Hardware",
                "anticipated",
                "Volumes",
                "notion",
                "Sec"
            ]
        }
    },
    {
        "id": "34946287-8755-48a1-8c7f-5ab042601f46",
        "title": "",
        "chunk_text": "■EM is likely not capable of providing exponential asymptotic QA Equipped with the definitions of EVE and active volume, we next proceed to discuss the question of whether and in what context EM is useful for QA. We first consider the question of asymptotic QA. Section 4 describes the barriers towards the usability of EM for such QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "Equipped",
                "EVE",
                "question",
                "asymptotic",
                "volume",
                "capable",
                "providing",
                "exponential",
                "definitions",
                "active"
            ]
        }
    },
    {
        "id": "7ad14f02-9a2d-4455-a407-c0ec0be265ef",
        "title": "",
        "chunk_text": "We start by describing examples and general results, providing strong evidence that EM is expected to require a number of shots that grows exponentially with γV , in order to ensure a required accuracy. Here γ is the gate infidelity and V the active volume of a given instance of EVE.",
        "metadata": {
            "author": "",
            "keywords": [
                "results",
                "providing",
                "accuracy",
                "start",
                "describing",
                "general",
                "strong",
                "evidence",
                "expected",
                "require"
            ]
        }
    },
    {
        "id": "1c8b21fb-2031-4cab-b2f2-271986dce61e",
        "title": "",
        "chunk_text": "In cases where this exponential behavior holds, we show that if EM solves EVE for a given circuit in time TEM, the same task can be accomplished classically in a time which is bounded (roughly) as Tc = O(T 1/γ EM), i.e., Tc is at most polynomial, with degree 1/γ, in TEM. This rules out exponential (and in fact any non-polynomial) asymptotic QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "TEM",
                "EVE",
                "time",
                "roughly",
                "holds",
                "bounded",
                "polynomial",
                "degree",
                "exponential",
                "cases"
            ]
        }
    },
    {
        "id": "1f33d280-4aa4-40c1-8259-f90f88f8ab78",
        "title": "",
        "chunk_text": "We explain that it is still an open question whether the above exponential scaling as a function of γV is a generic behavior for all EM protocols and inputs to the EVE problem. Nevertheless, recent work significantly strengthened the case against exponential asymptotic QA with EM [5].",
        "metadata": {
            "author": "",
            "keywords": [
                "EVE",
                "problem",
                "exponential",
                "explain",
                "open",
                "question",
                "scaling",
                "function",
                "generic",
                "behavior"
            ]
        }
    },
    {
        "id": "be75051b-01f0-452a-89e8-92e65f4e342e",
        "title": "",
        "chunk_text": "By deriving a classical polynomial time simulation of any noisy quantum circuit (albeit when averaged over the inputs, and with the polynomial degree scaling as 1/γ2), the authors deduced that for the EVE problem in which the required accuracy is defined on average over inputs to the circuit, exponential asymptotic QA is ruled out. Interestingly, this leaves room for the 4 1 INTRODUCTION possibility of exponential asymptotic QA with EM in non-generic cases; however, the main message of Sec.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "polynomial",
                "inputs",
                "EVE",
                "asymptotic",
                "exponential",
                "albeit",
                "deriving",
                "classical",
                "time"
            ]
        }
    },
    {
        "id": "7b392d25-c5e8-407d-a37c-613dd555da1a",
        "title": "",
        "chunk_text": "4 is that EM cannot generically provide exponential asymptotic QA. ■The polynomial bound on the advantage of EM leaves ample room for finite QA Naively, the above statement could be interpreted to mean that the execution of quantum circuits using EM can be replaced by a classical simulation, so there is no point in using EM on a QPU at all.",
        "metadata": {
            "author": "",
            "keywords": [
                "generically",
                "provide",
                "exponential",
                "asymptotic",
                "Naively",
                "QPU",
                "simulation",
                "polynomial",
                "bound",
                "advantage"
            ]
        }
    },
    {
        "id": "737a2c08-9c8c-432a-940f-ed2548aa0aa0",
        "title": "",
        "chunk_text": "However, we observe that the large power 1/γ (e.g., a thousand!) in the above-mentioned polynomial relation between Tc and TEM quantifies a large slowdown of classical computation compared to EM. This implies that even though EM probably cannot exhibit exponential asymptotic QA, there is ample room for EM to enable dramatic finite QAs. In Sec. 5 we indeed argue why EM is expected to enable such finite QA in the very near future, for the useful EVE problem.",
        "metadata": {
            "author": "",
            "keywords": [
                "TEM",
                "large",
                "power",
                "thousand",
                "observe",
                "above-mentioned",
                "polynomial",
                "relation",
                "quantifies",
                "slowdown"
            ]
        }
    },
    {
        "id": "be6bb9bc-c098-421f-967b-71d8bd846b44",
        "title": "",
        "chunk_text": "■Circuit Volume Boosts can quantify the contribution of EM We therefore put forth a quantity that properly quantifies the contribution of EM to the execution of quantum circuits. Indeed, we claim that using EM, it is possible to use noisy hardware to execute quantum circuits of higher volume than is possible with the ‘bare’ execution, without EM.",
        "metadata": {
            "author": "",
            "keywords": [
                "contribution",
                "Boosts",
                "Volume",
                "circuits",
                "quantum",
                "execution",
                "quantify",
                "put",
                "quantity",
                "properly"
            ]
        }
    },
    {
        "id": "4a102b84-a3e1-460c-88b8-46edfcd412fa",
        "title": "",
        "chunk_text": "Namely, we fix the allowed shot overhead and the desired output accuracy, and consider the maximal active volume that can be obtained by naive circuit execution, as opposed to the maximal active volume possible with EM. In Sec. 5.1 we define the ratio of these maximal volumes to be the circuit volume boost (CVB) of EM in the particular setting; Fig. 1 shows the expected CVBs as a function of the required output accuracy.",
        "metadata": {
            "author": "",
            "keywords": [
                "active",
                "maximal",
                "volume",
                "accuracy",
                "execution",
                "output",
                "fix",
                "allowed",
                "shot",
                "overhead"
            ]
        }
    },
    {
        "id": "288be342-eca8-436a-b1ae-4869af850e8c",
        "title": "",
        "chunk_text": "For example, EM is expected to enable circuit volume boosts of over a 100 (!) for required accuracy of 99% with a mild allowed shot overhead of 10. Furthermore, the better the required accuracy (and allowed shot overhead), the larger the CVBs that will be provided, namely the more beneficial it is to apply EM. We argue that the CVB is the proper way to quantify the contribution of EM to quantum circuit execution on noisy hardware. ■Dramatic finite QAs expected using EM, way before EC In Sec.",
        "metadata": {
            "author": "",
            "keywords": [
                "shot",
                "required",
                "accuracy",
                "allowed",
                "overhead",
                "enable",
                "volume",
                "boosts",
                "mild",
                "circuit"
            ]
        }
    },
    {
        "id": "dde733fc-7e70-41ab-b57e-cc9fb15ecc71",
        "title": "",
        "chunk_text": "5.2 we discuss the expected impact of EM in the near future. We argue that EM is likely to be the first error reduction method to enable useful finite QA. We predict that this will be achieved for the fundamental task of EVE, namely, extracting accurate expectation value estimations from ideal (noise free) generic quantum circuits. We expect this milestone to be achieved as soon as hardware platforms reach 50 qubits with an average two-qubit gate fidelity of 99.9%.",
        "metadata": {
            "author": "",
            "keywords": [
                "future",
                "discuss",
                "expected",
                "impact",
                "achieved",
                "EVE",
                "argue",
                "error",
                "reduction",
                "method"
            ]
        }
    },
    {
        "id": "94b7e2b3-400a-41c1-82fc-13e22e86259f",
        "title": "",
        "chunk_text": "We note that these hardware requirements will certainly be achieved before quantum computations on 50 logical qubits will be available using error correction alone (see Tab. 2); which means that finite QAs will be achieved first, and by a large margin, by EM before it is achieved by EC! Our predictions are given in Fig. 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "Tab",
                "achieved",
                "logical",
                "note",
                "hardware",
                "requirements",
                "quantum",
                "computations",
                "qubits",
                "error"
            ]
        }
    },
    {
        "id": "196126e2-1b01-45c8-9d8d-3e564e75db47",
        "title": "",
        "chunk_text": "We additionally discuss the relation between the circuit geometry (shape of the active volume) and the relative run time of EM compared to classical simulation, providing geometrical guidelines for the construction of early finite QA demonstrations. ■EM, combined with EC, will continue to provide large circuit volume boosts even in the fault tolerant EC era In Sec. 6 we turn to the important discussion of the role of quantum EM when fault-tolerant EC becomes available.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "volume",
                "geometry",
                "shape",
                "simulation",
                "providing",
                "demonstrations",
                "additionally",
                "discuss",
                "relation"
            ]
        }
    },
    {
        "id": "d0ac90ab-5440-4dca-921d-e231b0175f09",
        "title": "",
        "chunk_text": "It is a common misconception that once EC is available to end users, there will not be any need in other error reduction methods. We explain why this is indeed a misconception: even when fault-tolerant EC is available to end users, the fact that the number of high quality qubits is likely to remain limited in the foreseeable future, means that the logical error cannot be reduced to an arbitrary small value, and thus, fault tolerant quantum computations will also be limited in their volumes.",
        "metadata": {
            "author": "",
            "keywords": [
                "users",
                "end",
                "methods",
                "misconception",
                "error",
                "common",
                "reduction",
                "limited",
                "future",
                "fault"
            ]
        }
    },
    {
        "id": "f6c93ad7-e4b3-4d4b-8220-f96ccd9f8acb",
        "title": "",
        "chunk_text": "We then explain how EM can provide large circuit volume boosts over those available by EC alone, making it extremely useful also when EC is available. This will be achieved by combining EC with EM, and will dramatically push the limits of circuit volumes provided by EC alone, multiplying available circuit volumes by orders of magnitude. The expected CVBs provided by this combination, which we call logical error mitigation, are given in Fig. 3.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "volumes",
                "making",
                "explain",
                "provide",
                "large",
                "boosts",
                "extremely",
                "provided",
                "volume"
            ]
        }
    },
    {
        "id": "1d28a45e-0666-47a0-8601-8399c3b8a25c",
        "title": "",
        "chunk_text": "This figure is based on simulations of the prototypical Steane EC code combined with EM, and we provide in Tab. 2 order of magnitude estimates for state of the art EC codes. Thus, we argue that EM is not just a “transition technology” for the NISQ era that bridges the gap until fault tolerant EC is achieved and becomes available to end-users, but rather an important resource that is applicable whenever the number of high-quality qubits cannot be scaled without a significant cost.",
        "metadata": {
            "author": "",
            "keywords": [
                "Tab",
                "Steane",
                "figure",
                "based",
                "simulations",
                "prototypical",
                "combined",
                "provide",
                "code",
                "codes"
            ]
        }
    },
    {
        "id": "2ba82b51-be6d-40b1-8650-45ac4c072f84",
        "title": "",
        "chunk_text": "Specifically, we believe that it is the combination of EM and EC that will first enable reaching the milestone of MegaQuOp (one million logical gates) [56, 57]. 5 2 ASYMPTOTIC VS. FINITE QUANTUM ADVANTAGE (QA) ■Conclusions regarding the central role of EM and the quantum advantage timeline We conclude our manuscript (Sec. 7) with our future prospects, expressed as a QA timeline (Tab. 3).",
        "metadata": {
            "author": "",
            "keywords": [
                "Specifically",
                "MegaQuOp",
                "gates",
                "QUANTUM",
                "ADVANTAGE",
                "combination",
                "enable",
                "reaching",
                "milestone",
                "million"
            ]
        }
    },
    {
        "id": "2e074fc3-e89b-4c14-b2bc-d9793d5c1220",
        "title": "",
        "chunk_text": "This Table draws the implications of the main points in the paper, and highlights the central role that EM is expected to play in the future of the field. 2 Asymptotic vs. finite quantum advantage (QA) The notion of quantum algorithmic advantage or in short quantum advantage (QA) aims to capture the ability to solve problems with a real quantum computer (QPU) using much fewer resources than without it.",
        "metadata": {
            "author": "",
            "keywords": [
                "Table",
                "quantum",
                "advantage",
                "paper",
                "field",
                "draws",
                "implications",
                "main",
                "points",
                "highlights"
            ]
        }
    },
    {
        "id": "10f73b3a-20bc-495f-8a14-a0c22baa8893",
        "title": "",
        "chunk_text": "This notion is of major interest to both industry and academia; however, it is not well defined in the literature and there are substantial misconceptions about its meaning. In this section we point out an important distinction between different flavors of this notion: the mathematical concept of asymptotic QA; the concept of finite QA achieved in a finite-size real system - and the concept of scalable QA which is in fact a finite sequence of finite QAs whose behavior fits a certain scaling.",
        "metadata": {
            "author": "",
            "keywords": [
                "concept",
                "notion",
                "academia",
                "meaning",
                "finite",
                "major",
                "interest",
                "industry",
                "defined",
                "literature"
            ]
        }
    },
    {
        "id": "96089805-1596-4195-8689-bd1618810c31",
        "title": "",
        "chunk_text": "In the current public discourse about QA, all these notions (and perhaps others as well) are often used interchangeably, as if they are one and the same. However, for the discussion regarding the usefulness of EM, the question of which QA we are considering is crucial. We devote this section to clarifying these notions and the differences between them.",
        "metadata": {
            "author": "",
            "keywords": [
                "interchangeably",
                "notions",
                "current",
                "public",
                "discourse",
                "crucial",
                "discussion",
                "usefulness",
                "question",
                "devote"
            ]
        }
    },
    {
        "id": "ab2a215e-8268-40d0-a959-2c13a89d459e",
        "title": "",
        "chunk_text": "The definitions are not fully formal, and there are also many possible variants; however the important points that distinguish between the various flavors is what we care about here. 2.1 Asymptotic QA Let us first recall the well known mathematical notion of QA, which we call asymptotic QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "formal",
                "variants",
                "Asymptotic",
                "definitions",
                "fully",
                "important",
                "points",
                "distinguish",
                "flavors",
                "care"
            ]
        }
    },
    {
        "id": "4c2f3a5f-97e9-41a2-8c08-4fa61a42a4e7",
        "title": "",
        "chunk_text": "It considers the relation between the computational complexity (complexity, in short) of solving a certain problem using a classical computer versus a QPU (the QPU may also interact with a classical computer in a hybrid manner). The classical and quantum complexities are denoted SC(n) and SQ(n), respectively where n is the size of the input to the problem (or some parameter closely related to the input size that characterizes the scaling of the problem).",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "complexity",
                "computer",
                "classical",
                "problem",
                "short",
                "manner",
                "relation",
                "computational",
                "solving"
            ]
        }
    },
    {
        "id": "a951eba7-9723-49bc-8bc1-84ff4e917cba",
        "title": "",
        "chunk_text": "These complexities are often measured in the quantum computer science literature by the number of elementary gates used in the computation; alternatively, those can refer to the depth of the circuits used, which is an abstraction of the run time that the computation requires. Definition 2.1 (Asymptotic QA) Asymptotic QA on a given computational problem is achieved if limn→∞ SQ(n) SC(n) = 0. If in addition SC(n) ≤poly(SQ(n), n) we say that the QA is (at most) polynomial.",
        "metadata": {
            "author": "",
            "keywords": [
                "computation",
                "Asymptotic",
                "alternatively",
                "requires",
                "complexities",
                "measured",
                "quantum",
                "computer",
                "science",
                "literature"
            ]
        }
    },
    {
        "id": "2189eb2a-ccad-4c38-a8b0-cdaf9552a51f",
        "title": "",
        "chunk_text": "If SQ(n) ≤poly(log(SC(n)), n) we say that the asymptotic QA is (at least) exponential.",
        "metadata": {
            "author": "",
            "keywords": [
                "poly",
                "log",
                "exponential",
                "asymptotic"
            ]
        }
    },
    {
        "id": "fae4cfed-a7fb-4730-8c95-5168dd7c7eb1",
        "title": "",
        "chunk_text": "It is widely agreed by the scientific community that asymptotic QA holds for a variety of problems [58], in particular, the factoring problem (due to Shor’s quantum algorithm [8]) and the problem of simulating the dynamics of quantum systems [59].6 We note that Definition 2.1 can be instantiated where the underlying quantum model is either an ideal QPU or a noisy QPU, due to the quantum fault tolerance theorem [11–14].",
        "metadata": {
            "author": "",
            "keywords": [
                "due",
                "QPU",
                "quantum",
                "Definition",
                "Shor",
                "problem",
                "algorithm",
                "systems",
                "theorem",
                "widely"
            ]
        }
    },
    {
        "id": "db0ec8f8-09c1-4ba3-825a-446d80688b73",
        "title": "",
        "chunk_text": "Therefore, the asymptotic notion is robust to the noise in the model, as long as the noise rate is below the fault tolerance threshold, and the number of physical qubits with this noise rate is unlimited. 2.2 Finite QA A major question that concerns the quantum community is whether and when we will see experimental demonstrations of QAs for a variety of useful problems.",
        "metadata": {
            "author": "",
            "keywords": [
                "noise",
                "rate",
                "model",
                "threshold",
                "unlimited",
                "asymptotic",
                "notion",
                "robust",
                "long",
                "fault"
            ]
        }
    },
    {
        "id": "870c4910-35a1-4ba4-a4ff-46ff19b3fe0a",
        "title": "",
        "chunk_text": "We thus need to formalize notions of QA that 6In computer science, providing a rigorous proof that quantum computation cannot be simulated in polynomial time by classical computers, would imply a resolution of the long standing seminal open problem of whether P = PSPACE. However it is widely conjectured that exponential asymptotic QA holds, and restricted proofs exist in the black box model for several oracle problems, e.g., Simon’s problem [7]. 6 2 ASYMPTOTIC VS.",
        "metadata": {
            "author": "",
            "keywords": [
                "PSPACE",
                "science",
                "providing",
                "asymptotic",
                "Simon",
                "formalize",
                "notions",
                "rigorous",
                "quantum",
                "computation"
            ]
        }
    },
    {
        "id": "3d231757-3058-4c68-baed-930c11989140",
        "title": "",
        "chunk_text": "FINITE QUANTUM ADVANTAGE (QA) are closer to experimental realizations. In particular, this requires quantifying the physical resources that are used by real physical quantum and classical computers. Indeed, the complexity measures mentioned above do not seem to directly correspond to a physically measurable quantity of interest in the real world.",
        "metadata": {
            "author": "",
            "keywords": [
                "FINITE",
                "ADVANTAGE",
                "QUANTUM",
                "realizations",
                "closer",
                "experimental",
                "physical",
                "real",
                "computers",
                "world"
            ]
        }
    },
    {
        "id": "a4e54602-f5cb-42a8-9372-d8c7181d04b8",
        "title": "",
        "chunk_text": "Before we discuss the appropriate complexity measures that are more adequate to experimental settings, we first clarify the context in which such experiments might take place. We consider two competitors attempting to solve a computational problem: one with access only to a classical computer, and the other with access to a quantum and a classical computer combined in a hybrid manner.",
        "metadata": {
            "author": "",
            "keywords": [
                "settings",
                "place",
                "classical",
                "discuss",
                "complexity",
                "measures",
                "adequate",
                "experimental",
                "clarify",
                "context"
            ]
        }
    },
    {
        "id": "eefeb814-e232-44c1-95aa-0dc3bb1ffd19",
        "title": "",
        "chunk_text": "To compare the physical resources required by the two competitors for solving a certain computational problem, we need to put their resources on the same scale. This is a challenging task since the resources used by quantum and classical computational devices are very different in character, and strongly depend on the particulars of the hardware.",
        "metadata": {
            "author": "",
            "keywords": [
                "resources",
                "problem",
                "scale",
                "computational",
                "compare",
                "physical",
                "required",
                "competitors",
                "solving",
                "put"
            ]
        }
    },
    {
        "id": "814d6994-b027-4fba-b1aa-e8bd0f4a89ce",
        "title": "",
        "chunk_text": "We will return to this question at the end of this section, but for now presume that we can quantify the cost for solving a given computational problem using the best available quantum and classical hardware and software as Q = Q(n), (n being the aforementioned scaling parameter of the problem) and its cost using the best available classical hardware and software as C = C(n).",
        "metadata": {
            "author": "",
            "keywords": [
                "hardware",
                "software",
                "classical",
                "cost",
                "problem",
                "section",
                "return",
                "question",
                "end",
                "presume"
            ]
        }
    },
    {
        "id": "328ea541-cdee-4ff8-8b8e-caffee7912d1",
        "title": "",
        "chunk_text": "Importantly, these definitions consider the best available hardware and software, rather than the best possible as in the asymptotic definition. This is because when we discuss experimental demonstrations of QA, we attempt to capture a snapshot of the added value of quantum computers over classical at a specific point in time, rather than provide a prediction for idealized future hardware.",
        "metadata": {
            "author": "",
            "keywords": [
                "Importantly",
                "software",
                "hardware",
                "asymptotic",
                "definitions",
                "time",
                "discuss",
                "experimental",
                "demonstrations",
                "attempt"
            ]
        }
    },
    {
        "id": "ba06fa2b-23ff-4d05-9d35-7d4f2ad6802d",
        "title": "",
        "chunk_text": "The latter question is in the regime of computational complexity theory, while here we are attempting to formally address the question of achieving QA on existing physical devices, at a given point in time. We first define QA in a non-asymptotic setting, i.e. finite QA which considers a fixed value of n. It is somewhat harder to make a precise definition in this context, but we can consider the rather informal one below.",
        "metadata": {
            "author": "",
            "keywords": [
                "question",
                "theory",
                "devices",
                "time",
                "regime",
                "computational",
                "complexity",
                "attempting",
                "formally",
                "address"
            ]
        }
    },
    {
        "id": "6fc44129-442d-43cd-ac9b-a3bf16bfa3a6",
        "title": "",
        "chunk_text": "Definition 2.2 (Finite QA) For a given computational problem L, let In be the set of inputs to L of size n. Finite QA for L on inputs of size n is achieved if Q(n) ≪C(n), where Q(n) is the expected cost of the quantum algorithm over the inputs in In, and similarly C(n) is the expected cost of the classical algorithm over the inputs in In.",
        "metadata": {
            "author": "",
            "keywords": [
                "Finite",
                "inputs",
                "size",
                "Definition",
                "expected",
                "cost",
                "computational",
                "problem",
                "set",
                "algorithm"
            ]
        }
    },
    {
        "id": "ceb8e28e-0007-4a94-88c7-8c6829314dc0",
        "title": "",
        "chunk_text": "The reason for requiring that Q(n) ≪C(n) and not just Q(n) < C(n) is that the evaluation of the costs for the best currently available computers involves a large amount of arbitrariness, and may change from one day to the next. Indeed a robust definition will require a large concrete gap between the two that will be agreed upon universally.",
        "metadata": {
            "author": "",
            "keywords": [
                "large",
                "arbitrariness",
                "reason",
                "requiring",
                "evaluation",
                "costs",
                "computers",
                "involves",
                "amount",
                "change"
            ]
        }
    },
    {
        "id": "63003983-7d42-42f1-a1c8-3b390e39387c",
        "title": "",
        "chunk_text": "We note that Definition 2.2 does not specify a procedure for the jury in a QA competition to verify that finite QA had been achieved; this may be a challenging task on its own. One may imagine a competition attempting to demonstrate finite QA for some problem, for some given fixed n. How would that work?",
        "metadata": {
            "author": "",
            "keywords": [
                "Definition",
                "achieved",
                "finite",
                "competition",
                "note",
                "procedure",
                "jury",
                "verify",
                "challenging",
                "task"
            ]
        }
    },
    {
        "id": "c52c8dd3-f77e-4991-8ddb-d26e7a18dc37",
        "title": "",
        "chunk_text": "The competition may involve asking the competitors to run their respective algorithms on inputs chosen from some distribution over In for the fixed n, and the judge would then need to determine first whether the algorithms indeed output correct results, and secondly, the judge would also need to estimate the average costs and determine whether indeed Q(n) ≪C(n). Remark 1 (The size of In) We note that it is desirable to choose In to be a large set, rather than a single instance or just a few.",
        "metadata": {
            "author": "",
            "keywords": [
                "judge",
                "algorithms",
                "determine",
                "results",
                "competition",
                "involve",
                "competitors",
                "run",
                "respective",
                "inputs"
            ]
        }
    },
    {
        "id": "b91819c7-ea08-4dc0-bea5-bb356836086e",
        "title": "",
        "chunk_text": "The reason is that in practice, if the competition is defined to be on a single instance, both players will fine-tune their apparatus and algorithm to work optimally on that specific instance. Demonstrating an advantage for that particular instance will then not be indicative regarding performance on any other instance.",
        "metadata": {
            "author": "",
            "keywords": [
                "instance",
                "practice",
                "reason",
                "competition",
                "defined",
                "single",
                "players",
                "fine-tune",
                "apparatus",
                "algorithm"
            ]
        }
    },
    {
        "id": "26e5755d-5084-4547-9289-64ea1261552f",
        "title": "",
        "chunk_text": "Presumably, the goal of the QA competition is to provide a proof of principle that the QPU can (or cannot) achieve the advantage not just for the particular instance on which it was tested, but also more generally, for some interesting class of instances.7 7In the theory of computer science this question is related to the question of whether or not the resources invested in preprocessing are limited or not; more formally, this can be viewed as the question of whether we are working in the uniform or non-uniform circuit model.",
        "metadata": {
            "author": "",
            "keywords": [
                "question",
                "QPU",
                "achieve",
                "tested",
                "generally",
                "formally",
                "model",
                "goal",
                "competition",
                "provide"
            ]
        }
    },
    {
        "id": "ef9cf905-0a6a-4791-8197-f8cd9053a7e7",
        "title": "",
        "chunk_text": "7 2 ASYMPTOTIC VS. FINITE QUANTUM ADVANTAGE (QA) While there are still debates about particular experiments, it is generally agreed in the community that finite QA had already been demonstrated experimentally. Experiments claiming such finite QA include RCS and Boson Sampling, as well as other examples [28, 34–39].8 As mentioned in the introduction, useful finite QA is yet to be demonstrated, and we discuss in Sec.",
        "metadata": {
            "author": "",
            "keywords": [
                "ASYMPTOTIC",
                "FINITE",
                "ADVANTAGE",
                "QUANTUM",
                "experiments",
                "demonstrated",
                "Sampling",
                "Sec",
                "RCS",
                "Boson"
            ]
        }
    },
    {
        "id": "bf8d9d06-bcd3-4189-bdd1-68bd93e600df",
        "title": "",
        "chunk_text": "3 a leading candidate problem for this goal, namely, expectation value estimation. 2.3 Scalable QA The experimental demonstration of finite QA is a remarkable achievement of the quantum community, but it is still not close enough to the fantastic notion of exponential asymptotic QAs promised by the theoretical discoveries of quantum algorithms.",
        "metadata": {
            "author": "",
            "keywords": [
                "goal",
                "expectation",
                "estimation",
                "leading",
                "candidate",
                "problem",
                "Scalable",
                "quantum",
                "community",
                "algorithms"
            ]
        }
    },
    {
        "id": "33e467c3-bd5c-4a00-991b-184d13766fff",
        "title": "",
        "chunk_text": "One may consider a notion which is closer to asymptotic QA, in which one could demonstrate a sequence of finite QAs, over some range of n’s, such that those finite QAs fit a certain scaling (polynomial or exponential) as a function of n.",
        "metadata": {
            "author": "",
            "keywords": [
                "finite",
                "QAs",
                "scaling",
                "polynomial",
                "exponential",
                "notion",
                "closer",
                "asymptotic",
                "demonstrate",
                "sequence"
            ]
        }
    },
    {
        "id": "bd587786-18b5-43c8-8887-aeaa859dd8fe",
        "title": "",
        "chunk_text": "Given that this is a real world notion, it is impossible to “prove” that this scaling is maintained for all n, as one would hope for in order to validate the mathematical asymptotic notion of QA – however one may consider it a pretty convincing evidence if the scaling seems to behave like an exponent or a polynomial in some large regime of n’s. One can refer to this type of QA as scalable finite QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "prove",
                "notion",
                "scaling",
                "real",
                "world",
                "impossible",
                "maintained",
                "hope",
                "order",
                "validate"
            ]
        }
    },
    {
        "id": "0d0799ea-64b5-4569-a0d5-c706dd027c8d",
        "title": "",
        "chunk_text": "Achieving experimental demonstration of scalable QA is a major goal of the quantum community; we do not consider this notion of QA further in this exposition (for recent progress on scalable QA see, e.g., [60]). 2.4 Asymptotic QA vs. Finite QA Despite the evident difference between finite and asymptotic QA, there is often a confusion in the literature regarding which of these notions of QA is appropriate to use in different contexts.",
        "metadata": {
            "author": "",
            "keywords": [
                "scalable",
                "Achieving",
                "community",
                "exposition",
                "Asymptotic",
                "Finite",
                "experimental",
                "demonstration",
                "major",
                "goal"
            ]
        }
    },
    {
        "id": "02280b83-e0a5-4686-9128-11af1b4c838c",
        "title": "",
        "chunk_text": "We make several important remarks regarding the relations between these two notions. Remark 2 (Does Asymptotic QA imply finite QA, or vice versa?) We note that asymptotic QA and finite QA are in general incomparable, and it is possible that one holds but not the other, for a given problem. For example consider a problem for which we believe that asymptotic QA holds (e.g., factoring).",
        "metadata": {
            "author": "",
            "keywords": [
                "Asymptotic",
                "notions",
                "make",
                "important",
                "relations",
                "finite",
                "holds",
                "problem",
                "remarks",
                "Remark"
            ]
        }
    },
    {
        "id": "f08ede2c-5350-4325-a388-b71a317564e5",
        "title": "",
        "chunk_text": "Mathematically, for any reasonable choice of definition for Q(n) and C(n) (and their relation to SQ(n) and SC(n) of Def. 2.1), respectively, such asymptotic QA implies that for a large enough n we will have Q(n) ≪C(n). Based on this, and using quantum fault tolerance, in principle one should be able to experimentally demonstrate finite QA, for some large enough finite n.",
        "metadata": {
            "author": "",
            "keywords": [
                "Def",
                "Mathematically",
                "reasonable",
                "choice",
                "definition",
                "relation",
                "large",
                "finite",
                "asymptotic",
                "implies"
            ]
        }
    },
    {
        "id": "f64abeaf-6927-4969-98c6-54342956422a",
        "title": "",
        "chunk_text": "However it might be that this requires working with numbers of qubits which are too large to reach due to some technological barriers, and hence finite QA would not be achievable in our physical world, at least for this particular computational problem.",
        "metadata": {
            "author": "",
            "keywords": [
                "barriers",
                "world",
                "problem",
                "requires",
                "working",
                "numbers",
                "qubits",
                "large",
                "reach",
                "due"
            ]
        }
    },
    {
        "id": "10bc0d1e-dbda-4954-891d-c5c99a7d793c",
        "title": "",
        "chunk_text": "On the other hand, it is conceivable that finite QA is achievable in our real world for some problem, for some fixed n, but on the other hand this problem does not exhibit asymptotic QA at all, and the finite QA is simply an artifact of some finite size phenomenon that does not scale. Which of the two notions, finite QAs or asymptotic QAs, is more interesting or relevant for quantum computation? This is a difficult and possibly confusing question.",
        "metadata": {
            "author": "",
            "keywords": [
                "hand",
                "finite",
                "problem",
                "scale",
                "asymptotic",
                "conceivable",
                "achievable",
                "real",
                "world",
                "fixed"
            ]
        }
    },
    {
        "id": "15a6f64a-acec-4519-bdb1-46abb06879fd",
        "title": "",
        "chunk_text": "Much of the interest in quantum computation is practical, and comes from the industry and applications side; it relies on the strong belief that QAs will be realizable in the real world, and in particular, that for certain sizes of inputs for problems of practical interest, the actual relevant measure of costs on a QPU, say the wall-clock run time, will be shorter than that required to achieve this task on a classical computer. Achieving finite QAs is thus a leading goal.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "interest",
                "practical",
                "side",
                "world",
                "time",
                "computer",
                "QAs",
                "quantum",
                "computation"
            ]
        }
    },
    {
        "id": "930f4cf7-0061-4444-8ff7-7d4dc88241a6",
        "title": "",
        "chunk_text": "However, since such finite QAs may be due to a “finite size effect” that may become irrelevant as the system sizes grow. It is theoretical asymptotic algorithmic results such as Shor’s algorithm, namely asymptotic QAs, that provide the scientific basis and motivation to seek for the experimental realization of finite QAs in the first place.",
        "metadata": {
            "author": "",
            "keywords": [
                "finite",
                "QAs",
                "effect",
                "grow",
                "due",
                "irrelevant",
                "system",
                "size",
                "sizes",
                "Shor"
            ]
        }
    },
    {
        "id": "2d7a5108-303f-4991-b1cd-a9115115c192",
        "title": "",
        "chunk_text": "As explained in Remark 2, asymptotic QA implies that finite QAs for this 8As an example, let us see how to view the RCS experiments of [34, 38] as instances of Def. 2.2. In this case In is the ensemble of n-qubits circuits from which the random circuit is drawn. The sampling task is to output a sequence of k n-bit strings xi such that the cross entropy benchmark fidelity, FXEB = 2n k Pk i=1 |⟨0n|C|xi⟩|2 −1, is above a certain threshold. 8 2 ASYMPTOTIC VS.",
        "metadata": {
            "author": "",
            "keywords": [
                "Remark",
                "Def",
                "RCS",
                "asymptotic",
                "explained",
                "implies",
                "finite",
                "QAs",
                "view",
                "experiments"
            ]
        }
    },
    {
        "id": "eb2c56d8-4536-4ccf-8244-6ce27bb4db9a",
        "title": "",
        "chunk_text": "FINITE QUANTUM ADVANTAGE (QA) problem are to be expected starting from some “crossover point”. Indeed, humanity’s current endeavour towards experimental demonstrations of QA implicitly assumes that the crossover point is within our reach, and that the required n is not too large for our finite world. Whereas theoretical study does not guarantee that this is the case, we may draw inspiration from the technological ability to scale classical computing systems quite rapidly.",
        "metadata": {
            "author": "",
            "keywords": [
                "ADVANTAGE",
                "QUANTUM",
                "FINITE",
                "problem",
                "crossover",
                "point",
                "expected",
                "starting",
                "humanity",
                "reach"
            ]
        }
    },
    {
        "id": "aaa594ab-7da4-4cd5-97c8-d63720683216",
        "title": "",
        "chunk_text": "As we argue in this manuscript, the important role of EM is to enable higher circuit volumes for a given hardware, thus reaching the crossover point earlier (see Sec. 5). This discussion reveals an inherent tension between the practical, finite world and the asymptotic approach of computational complexity; it is indeed rightfully confusing, and has been a constant source of misunderstandings in the literature and study of QAs.",
        "metadata": {
            "author": "",
            "keywords": [
                "Sec.",
                "manuscript",
                "hardware",
                "earlier",
                "argue",
                "important",
                "role",
                "enable",
                "higher",
                "circuit"
            ]
        }
    },
    {
        "id": "eefe5979-5985-46a1-b6b8-dfe1ccce39c4",
        "title": "",
        "chunk_text": "We believe that maintaining the distinction between asymptotic and finite QAs may significantly help avoid these misunderstandings. 2.5 Quantifying resources Before we move on, we remark on the question which we have allowed ourselves to evade so far in this section - how to quantify the realistic costs Q and C. We discuss several possibilities in broad strokes.",
        "metadata": {
            "author": "",
            "keywords": [
                "misunderstandings",
                "maintaining",
                "distinction",
                "asymptotic",
                "finite",
                "QAs",
                "significantly",
                "avoid",
                "Quantifying",
                "section"
            ]
        }
    },
    {
        "id": "023920f5-0756-4d8b-9750-c706891e0c10",
        "title": "",
        "chunk_text": "One possibility is to adapt the notion of circuit size (the number of quantum/classical gates used in an execution) to a metric which is adequate for finite QA. Quantum and classical gates are not comparable. To make Q, C measure resources on the same scale, we can decide on a conversion factor between them. Such a conversion factor does not matter from an asymptotic point of view, so does not concern us when we discuss asymptotic QA. However there seem to be severe drawbacks to this approach.",
        "metadata": {
            "author": "",
            "keywords": [
                "classical",
                "gates",
                "size",
                "execution",
                "quantum",
                "possibility",
                "adapt",
                "notion",
                "circuit",
                "number"
            ]
        }
    },
    {
        "id": "9426c364-9ce7-4f8b-9878-73d10ebc687e",
        "title": "",
        "chunk_text": "Firstly, this metric seems to be much more cumbersome to use in the context of finite QA, where the constants are crucial - especially when hybrid quantum computation making use of classical computers is involved. More importantly, the circuit complexity metric of number of gates does not distinguish between time and space (i.e. number of bits/qubits being used), since it considers, essentially, only their product.",
        "metadata": {
            "author": "",
            "keywords": [
                "Firstly",
                "crucial",
                "involved",
                "metric",
                "cumbersome",
                "context",
                "finite",
                "constants",
                "hybrid",
                "quantum"
            ]
        }
    },
    {
        "id": "f67594ab-f154-409e-8603-3f66ec2a3417",
        "title": "",
        "chunk_text": "However space and time might be very different in their importance for resource counting; and their importance within quantum and classical computation is also very different, a difference which is hard to assign a convergence rate to. One can define instead Q, C using wall-clock time (which roughly corresponds to another metric commonly used in computational complexity: the depth of the circuit, namely the number of its layers).",
        "metadata": {
            "author": "",
            "keywords": [
                "importance",
                "counting",
                "time",
                "space",
                "resource",
                "quantum",
                "classical",
                "computation",
                "difference",
                "hard"
            ]
        }
    },
    {
        "id": "d0a9f7d7-3097-430a-a81e-59b9410033e1",
        "title": "",
        "chunk_text": "This choice is in line with contemporary QA demonstrations, where the goal is to beat the best available classical super-computer in terms of run time, regardless of its size, energy consumption and other considerations. Both above metrics ignore many resources, such as cost in dollars, energy consumption, economic costs, and more. For example, see Ref. [61] for an estimation of the classical cost for simulating RCS in $s, and Ref. [34] for energy consumption estimations.",
        "metadata": {
            "author": "",
            "keywords": [
                "energy",
                "consumption",
                "Ref",
                "demonstrations",
                "time",
                "size",
                "considerations",
                "choice",
                "line",
                "contemporary"
            ]
        }
    },
    {
        "id": "3e3756e3-a68e-417c-b6d8-11d15b09f436",
        "title": "",
        "chunk_text": "The number of qubits is another important resource, of course; see, e.g., Ref. [62] for a detailed exposition of qubit-number estimates. We note that no matter what metric is chosen, it can be mapped to a volume crossover point above which finite QA is reached w.r.t. this metric.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ref",
                "resource",
                "number",
                "qubits",
                "important",
                "metric",
                "estimates",
                "chosen",
                "reached",
                "detailed"
            ]
        }
    },
    {
        "id": "4acd78f0-d719-438a-99b9-7d38d1379743",
        "title": "",
        "chunk_text": "We further note that in all these metrics we did not account for the resources that go into preprocessing; it does not seem realistic nor practical to take into account the resources invested by the different competitors in preprocessing, as it seems extremely difficult to put a measure on such efforts.9 However, to a certain extent, the requirement that In is large (Remark 1) is a practical way to significantly reduce the importance of preprocessing performed by the competitors, and prevent it from making the competition meaningless.",
        "metadata": {
            "author": "",
            "keywords": [
                "Remark",
                "preprocessing",
                "resources",
                "account",
                "practical",
                "competitors",
                "extent",
                "large",
                "meaningless",
                "note"
            ]
        }
    },
    {
        "id": "34b5ed44-cbfb-47c6-98be-6a5af1615920",
        "title": "",
        "chunk_text": "Once In is large enough, the competitors would have to put an enormous amount of effort to fine tune their systems so that the algorithm will work for all (or most of) these inputs. 9In the language of theoretical computer science, this means that we are working in the non-uniform model that allows infinite preprocessing.",
        "metadata": {
            "author": "",
            "keywords": [
                "inputs",
                "large",
                "competitors",
                "put",
                "enormous",
                "amount",
                "effort",
                "fine",
                "tune",
                "systems"
            ]
        }
    },
    {
        "id": "f50ba34f-5cf3-4460-92a3-3fb390e47dfb",
        "title": "",
        "chunk_text": "9 3 EXPECTATION VALUE ESTIMATION 3 Expectation value estimation To further discuss finite and asymptotic QA, we focus on a concrete and ubiquitous problem, which is of great importance in quantum physics and chemistry, as well as in a variety of quantum algorithms, namely, the expectation value estimation (EVE) problem. This is the problem of estimating the expected value of some observable in a pure quantum state that is generated in some prescribed manner.",
        "metadata": {
            "author": "",
            "keywords": [
                "EXPECTATION",
                "ESTIMATION",
                "EVE",
                "problem",
                "quantum",
                "chemistry",
                "algorithms",
                "discuss",
                "finite",
                "asymptotic"
            ]
        }
    },
    {
        "id": "a86f96c7-2672-423d-9af0-4a5f136018c9",
        "title": "",
        "chunk_text": "Achieving finite QA for EVE is fundamentally important, as it would imply that an existing QPU is better at approximating ideal (noise-free) quantum computation than classical simulation methods run on HPC hardware.10 Practically, we expect that a QPU capable of demonstrating such finite QA will be useful for two purposes.",
        "metadata": {
            "author": "",
            "keywords": [
                "Practically",
                "noise-free",
                "HPC",
                "QPU",
                "EVE",
                "finite",
                "Achieving",
                "important",
                "ideal",
                "quantum"
            ]
        }
    },
    {
        "id": "2d358a28-b335-4558-8c3e-04c9528845b4",
        "title": "",
        "chunk_text": "First, such a machine will allow for the otherwise-impossible simulation of important problems in quantum many-body physics, and in particular condensed matter physics, e.g., Floquet and Hamiltonian time evolution [63]. Secondly, this may have an important impact on researchers working on designing quantum algorithms and adapting them to specific applications.",
        "metadata": {
            "author": "",
            "keywords": [
                "physics",
                "Floquet",
                "Hamiltonian",
                "evolution",
                "important",
                "quantum",
                "machine",
                "otherwise-impossible",
                "simulation",
                "problems"
            ]
        }
    },
    {
        "id": "bb1e1352-ff78-4e43-a54a-29a14e0467aa",
        "title": "",
        "chunk_text": "For lack of an alternative, researchers currently working on quantum algorithm design make extensive use of classical HPC to simulate their quantum algorithm’s performance [64], and are thus very limited in the sizes of the instances they can study. The ability to solve the EVE problem for larger and more general input quantum circuits would allow those researchers much more effective exploration of the behavior of their algorithms.",
        "metadata": {
            "author": "",
            "keywords": [
                "HPC",
                "quantum",
                "alternative",
                "performance",
                "study",
                "algorithm",
                "researchers",
                "lack",
                "working",
                "design"
            ]
        }
    },
    {
        "id": "0f263e73-a893-4f85-98d2-e06effef4176",
        "title": "",
        "chunk_text": "The important EVE problem lends itself naturally to EM methods, and thus it will be very convenient to focus on it in the remainder of this paper. We remark that one may consider other computational problems as a basis for finite QA, such as deterministic problems like Factoring [8], sampling problems like RCS [34], Boson-Sampling and IQP [65] and even more generally interactive protocols for computational tasks such as certifiable randomness [66].",
        "metadata": {
            "author": "",
            "keywords": [
                "EVE",
                "problems",
                "methods",
                "paper",
                "important",
                "lends",
                "naturally",
                "convenient",
                "focus",
                "remainder"
            ]
        }
    },
    {
        "id": "07cb5520-c31c-404d-9fb7-3b82548c55c2",
        "title": "",
        "chunk_text": "While EM methods are commonly referred to as appropriate mainly for EVE, there is an ongoing effort towards the application of EM to sampling problems (e.g., [67]). 3.1 Problem statement We define the problem of expectation value estimation in the realistic setting where we are interested in circuits and observables taken from some restricted prespecified family.",
        "metadata": {
            "author": "",
            "keywords": [
                "EVE",
                "Problem",
                "methods",
                "commonly",
                "referred",
                "ongoing",
                "effort",
                "application",
                "sampling",
                "problems"
            ]
        }
    },
    {
        "id": "732ebda1-4848-4192-941a-43f1e5b5422c",
        "title": "",
        "chunk_text": "Hence we consider a fixed family of sets I = {In}n where for each n, In is a set of pairs (C, O) with C a circuit acting on n qubits and O a tensor product observable acting on its output.",
        "metadata": {
            "author": "",
            "keywords": [
                "acting",
                "pairs",
                "output",
                "fixed",
                "family",
                "circuit",
                "qubits",
                "tensor",
                "product",
                "observable"
            ]
        }
    },
    {
        "id": "5216847f-2c1f-41b6-9052-bc5acf0589ee",
        "title": "",
        "chunk_text": "We require that there is an a-priori polynomial bound on the size of the circuits, as a function of n (formally, that there is a polynomial p, so that all circuits C in In have size at most p(n).) Definition 3.1 (Expectation Value Estimation (EVE)) The input to the expectation value estimation problem EVE[I] (we omit the parameter I when it is clear from the context) is a pair (C, O) ∈In for some n, comprising of a description of a quantum circuit C acting on n qubits and a description of a tensor product observable O over the output domain of C.",
        "metadata": {
            "author": "",
            "keywords": [
                "polynomial",
                "size",
                "EVE",
                "formally",
                "circuits",
                "Expectation",
                "Estimation",
                "description",
                "require",
                "a-priori"
            ]
        }
    },
    {
        "id": "d9239bf6-f03e-4e0e-8cdf-8208bce1aa64",
        "title": "",
        "chunk_text": "The output EVE(C, O) is an estimation of the expected value of O over the state C|0n⟩= |C(0n)⟩derived by applying C to the all 0 input state, namely, ⟨O⟩C := ⟨C(0n)|O|C(0n)⟩. We say that an algorithm A ϵ-approximates EVE(C, O) if the input pair (C, O) the mean-square error in the approximation (averaged over the randomness in the algorithm) is bounded by ϵ: q EA \u0002 |A(C, O) −⟨O⟩C|2\u0003 ≤ϵ = ϵ(n) .",
        "metadata": {
            "author": "",
            "keywords": [
                "EVE",
                "state",
                "input",
                "derived",
                "output",
                "estimation",
                "expected",
                "applying",
                "algorithm",
                "pair"
            ]
        }
    },
    {
        "id": "6bf24495-009c-4a6c-a63f-056f78280e36",
        "title": "",
        "chunk_text": "(1) With the convention that O is normalized in operator norm, ∥O∥op = 1, we consider a small ϵ ≪1, which may be a function of n. Note that the value ⟨O⟩C is a fixed number given the pair (C, O), and the expectation EA is taken over the randomness in the algorithm A, due to classical coin flips, quantum measurements, or both. The problem of ϵ-approximating EVE[I] is denoted EVEϵ[I].",
        "metadata": {
            "author": "",
            "keywords": [
                "norm",
                "convention",
                "normalized",
                "operator",
                "small",
                "function",
                "EVE",
                "Note",
                "pair",
                "due"
            ]
        }
    },
    {
        "id": "43e2fc22-c089-4432-a3ea-579db2d433ac",
        "title": "",
        "chunk_text": "10This should be contrasted with finite QA for RCS [34], which may be viewed as implying that an existing QPU is better at approximating noisy quantum computation than classical HPC. Indeed, in RCS it is sufficient to sample from a distribution whose distance from the output distribution of an ideal quantum circuit can be as large as 1 −F, where F is very small - it is the experimental circuit fidelity (e.g., F ∼10−3 −10−2 [34, 38]).",
        "metadata": {
            "author": "",
            "keywords": [
                "HPC",
                "QPU",
                "RCS",
                "quantum",
                "contrasted",
                "finite",
                "viewed",
                "implying",
                "existing",
                "approximating"
            ]
        }
    },
    {
        "id": "49a622b6-19e6-489a-b848-01f95189f798",
        "title": "",
        "chunk_text": "The large error bound 1 −F ≲1 should be contrasted with the small additive error ϵ ≪1 in EVE. 10 3 EXPECTATION VALUE ESTIMATION Remark 3 (Variations of EVE) The above definition considers worst-case accuracy, requiring that A performs well on the entire set In. We may also consider average case versions, where ϵ corresponds to the mean-squared-error over In. We also note that in the above definition, we allow only the all-zero state as an input to the circuit.",
        "metadata": {
            "author": "",
            "keywords": [
                "EVE",
                "error",
                "bound",
                "large",
                "contrasted",
                "small",
                "additive",
                "definition",
                "EXPECTATION",
                "Remark"
            ]
        }
    },
    {
        "id": "0a85b2e2-3209-46d9-9e9e-d93cca09b5ec",
        "title": "",
        "chunk_text": "Indeed, this is how circuits are executed in the lab in current implementations. In a variety of settings it is natural to consider all 2n inputs to the circuit; this is equivalent to considering 2n circuits with the all zero input, where the circuits are derived from the original one by adding a layer of single qubit gates at the beginning, which change the all-zero input to some other input string. 3.2 Active circuit volume In the remainder of this paper, in particular Sec.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuits",
                "input",
                "implementations",
                "circuit",
                "executed",
                "lab",
                "current",
                "Active",
                "Sec",
                "inputs"
            ]
        }
    },
    {
        "id": "504a6ffb-d14b-47e0-a5ff-504e78069611",
        "title": "",
        "chunk_text": "4 and 5, we will study the potential for both asymptotic and finite QA in EVEϵ, by comparing the run time of EM protocols with that of classical simulation methods. Each instance of EVEϵ is defined by the circuit and observable (C, O), and one may naively expect the hardness of each instance to be controlled by the total number of qubits on which C is defined, and by the total volume of C, measured as e.g., the total number of two-qubit gates in the circuit.",
        "metadata": {
            "author": "",
            "keywords": [
                "total",
                "EVEϵ",
                "methods",
                "number",
                "study",
                "potential",
                "asymptotic",
                "finite",
                "comparing",
                "run"
            ]
        }
    },
    {
        "id": "2070cc46-ef37-4db2-ac36-fdf41a71a580",
        "title": "",
        "chunk_text": "These, however, are naive metrics for the circuit size. A more refined convenient notion is the circuit active volume, which takes into account also the observable O and the accuracy ϵ: Definition 3.2 (Active circuit volume) Given an instance (C, O) of EVEϵ, its active circuit volume V is given by the size of the minimal subset of 2-qubit gates in C, such that arbitrary modifications to the gates in the complement of the subset lead to a negligible change of ⟨O⟩C relative to ϵ.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "active",
                "size",
                "volume",
                "naive",
                "metrics",
                "Definition",
                "gates",
                "subset",
                "instance"
            ]
        }
    },
    {
        "id": "71b40293-ce5a-4b4b-baa7-29453f9997c1",
        "title": "",
        "chunk_text": "That is, V = min n |S| : S ⊂C, ∀˜Sc | ⟨O⟩(C\\Sc)∪˜ Sc −⟨O⟩C | ≪ϵ o , (2) where Sc is the complement of a subset S ⊂C, and ˜Sc is any modification to the complement. Remark 4 (Allowed modifications) We intentionally leave vague the precise details of the allowed ‘arbitrary modification’ in Definition 3.2, as different conventions can be appropriate for different applications.",
        "metadata": {
            "author": "",
            "keywords": [
                "complement",
                "min",
                "Allowed",
                "subset",
                "Definition",
                "Remark",
                "modification",
                "arbitrary",
                "applications",
                "intentionally"
            ]
        }
    },
    {
        "id": "fba10ea6-7f4b-4354-9f11-f05d7d001a59",
        "title": "",
        "chunk_text": "For the purpose of this paper, it will suffice to consider the replacement of each k-qubit unitary gate in the complement by an arbitrary k-qubit unitary.11 By a small abuse of notation, we sometime refer to V as a subset of 2-qubit gates, and not just as the size of a subset. In the remainder of this paper, whenever we use the shorthand ‘active volume’, ‘circuit volume’, or simply ‘volume’, we always refer to active circuit volume, unless stated otherwise.",
        "metadata": {
            "author": "",
            "keywords": [
                "subset",
                "paper",
                "k-qubit",
                "volume’",
                "refer",
                "notation",
                "purpose",
                "suffice",
                "replacement",
                "unitary"
            ]
        }
    },
    {
        "id": "f7d57d99-99eb-49e4-97b1-a1a268ffe1ed",
        "title": "",
        "chunk_text": "The notion of active circuit volume captures, in some sense, the “relevant” volume for the problem; intuitively, one doesn’t care about gates outside of it. Classical algorithms for EVEϵ may benefit in run time from the removal of gates outside of V . Quantum-classical algorithms (such as EM), may alternatively ignore errors occurring outside of V .",
        "metadata": {
            "author": "",
            "keywords": [
                "volume",
                "relevant",
                "intuitively",
                "gates",
                "captures",
                "sense",
                "problem",
                "notion",
                "active",
                "circuit"
            ]
        }
    },
    {
        "id": "59e38959-4e7a-4cfd-b5f7-e1991437afca",
        "title": "",
        "chunk_text": "Note that algorithms that require the active volume to be a-priori identified in order to benefit from it must incorporate an active volume identification subroutine [68], and their performance will be affected by the performance of this subroutine. Finally, we also restrict attention to the “relevant” subset of qubits: Remark 5 (Active qubits) The active qubits are those qubits acted upon by any of the gates in the active volume.",
        "metadata": {
            "author": "",
            "keywords": [
                "active",
                "subroutine",
                "volume",
                "performance",
                "qubits",
                "Note",
                "Remark",
                "algorithms",
                "require",
                "a-priori"
            ]
        }
    },
    {
        "id": "98cd8f4e-b7d7-4662-a9e3-a7ddd53b734a",
        "title": "",
        "chunk_text": "In the remainder of the paper we make the assumption that all n qubits in the circuit are indeed active. Otherwise some qubits are not acted upon by any 2-qubit gate (after the removal of all gates outside of V ) and in principle can be removed from the circuit. The number n thus represents the ‘number of active qubits’ in the circuit C, with respect to the observable O and accuracy ϵ, and in particular, satisfies n ≤V .",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "qubits",
                "active",
                "remainder",
                "paper",
                "make",
                "assumption",
                "number",
                "gate",
                "gates"
            ]
        }
    },
    {
        "id": "2bb54185-fbd8-4a7e-ac6b-81bbbfcd7a56",
        "title": "",
        "chunk_text": "11The unitary replacement captures both the removal of gates outside of V , as well as the addition of errors outside of V , with commonly used error models (e.g., local Pauli channels), corresponding to independent probability distributions over k-qubit unitaries occurring after each k-qubit gate.",
        "metadata": {
            "author": "",
            "keywords": [
                "Pauli",
                "k-qubit",
                "unitary",
                "models",
                "local",
                "channels",
                "replacement",
                "captures",
                "removal",
                "addition"
            ]
        }
    },
    {
        "id": "a816d100-c8fd-4c87-bc9a-1948fa5f7a9e",
        "title": "",
        "chunk_text": "11 4 EVIDENCE AGAINST ASYMPTOTIC QA WITH EM 4 Evidence against asymptotic QA with EM It is long known that in order to handle the effect of the most disruptive type of errors in quantum computers, namely non-unitary or dissipative errors, one must constantly remove the entropy accumulated in the quantum system (e.g., [11, 69, 70]).",
        "metadata": {
            "author": "",
            "keywords": [
                "EVIDENCE",
                "ASYMPTOTIC",
                "errors",
                "quantum",
                "computers",
                "system",
                "long",
                "order",
                "handle",
                "effect"
            ]
        }
    },
    {
        "id": "afa84688-8d21-4351-b468-53114e162912",
        "title": "",
        "chunk_text": "Quantum error correction (EC) does this by employing a large overhead in qubit numbers due to (i) the encoding of logical qubits onto physical qubits, and (ii) the addition of measurement qubits, which are periodically reset or replaced between EC cycles.",
        "metadata": {
            "author": "",
            "keywords": [
                "qubits",
                "Quantum",
                "correction",
                "cycles",
                "error",
                "employing",
                "large",
                "overhead",
                "numbers",
                "due"
            ]
        }
    },
    {
        "id": "483ae195-97ca-455e-ab45-77cef8852c46",
        "title": "",
        "chunk_text": "In contrast to EC, error mitigation (EM) is a collective name for a family of methods to reduce the effect of errors in quantum computation without introducing fresh qubits during the computation, and importantly, while avoiding the large qubit overheads of EC. To do this, EM replaces the execution of a given target circuit by multiple noisy circuit executions; the results of which are post-processed to provide an estimate for the error-free output of the target circuit.",
        "metadata": {
            "author": "",
            "keywords": [
                "computation",
                "circuit",
                "mitigation",
                "importantly",
                "error",
                "errors",
                "qubits",
                "qubit",
                "contrast",
                "collective"
            ]
        }
    },
    {
        "id": "08c99f06-d049-4457-a824-693cfe213c10",
        "title": "",
        "chunk_text": "The fact that EM has little or no qubit overhead is a great benefit of EM over EC; however, this benefit comes at a painful price, which is the subject of this section. 4.1 Evidence for exponential sampling overhead of EM From its inception, it was understood that EM probably cannot lead to exponential QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "benefit",
                "price",
                "section",
                "overhead",
                "fact",
                "qubit",
                "great",
                "painful",
                "subject",
                "Evidence"
            ]
        }
    },
    {
        "id": "a7e78aa8-c64a-4526-b26e-007b355f9b95",
        "title": "",
        "chunk_text": "The reason is that, starting with the development of the first EM protocols [42–44], and continuing in subsequent extensions and protocols [41, 45–47], it was observed that, in order to produce an accurate output, the proposed protocols generically require a number of shots M which is exponential in the total infidelity affecting the measured observable: M ≥1 ϵ2 eλγV , (3) where ϵ is the required statistical error, γ is the 2-qubit (average) gate infidelity, V is the active circuit volume (Definition 3.2).",
        "metadata": {
            "author": "",
            "keywords": [
                "protocols",
                "Definition",
                "infidelity",
                "eλγV",
                "average",
                "starting",
                "output",
                "observable",
                "error",
                "gate"
            ]
        }
    },
    {
        "id": "8bb8b41c-dd33-4903-bdd7-8016ba17e824",
        "title": "",
        "chunk_text": "The product γV is the total infidelity within the active volume. The parameter λ appearing in the exponent may be referred to as the ‘blow-up rate’ of the specific EM method being used, and in the above described cases, it was found to be a constant (independent of n). For example, in EM based on QP distributions [42], it has been argued that λ ≥4, with the lower bound achieved in e.g., commonly-used constructions for Pauli channels [71–73]. As another example, in exponential ZNE (i.e.",
        "metadata": {
            "author": "",
            "keywords": [
                "volume",
                "product",
                "total",
                "infidelity",
                "active",
                "Pauli",
                "ZNE",
                "blow-up",
                "cases",
                "constant"
            ]
        }
    },
    {
        "id": "21c15ef4-9fee-48ad-bc71-238fce821bce",
        "title": "",
        "chunk_text": "ZNE with an exponential extrapolation function), it has been argued that λ ≥2, with the lower bound achieved by the two-point scheme described in [47].12 The above case by case study seems to suggest that a lower bound in the form of Eq. (3) may hold more generally; the following toy example may give some intuition for why that might be true.",
        "metadata": {
            "author": "",
            "keywords": [
                "ZNE",
                "lower",
                "bound",
                "case",
                "function",
                "exponential",
                "extrapolation",
                "argued",
                "achieved",
                "two-point"
            ]
        }
    },
    {
        "id": "e9a8df29-b22d-4054-a40c-025ec122458c",
        "title": "",
        "chunk_text": "Consider the global n-qubit depolarizing error model, where a channel Dq : ρ 7→(1−q)ρ+qtr(ρ)I/2n, with depolarizing probability q ∈[0, 1], acts after each of the V ideal unitary gates in the circuit. Since Dq commutes with all unitary gates, all V copies of Dq can be pulled to the end of the circuit, where they contract a trace-less observable O as O 7→(1 −q)V O. To mitigate this effect, we may consider the following toy EM protocol.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "depolarizing",
                "qtr",
                "unitary",
                "gates",
                "model",
                "acts",
                "global",
                "n-qubit",
                "error"
            ]
        }
    },
    {
        "id": "14c17f00-0a76-4f10-b7f8-716aaf903e65",
        "title": "",
        "chunk_text": "The protocol estimates the noisy expectation value ⟨O⟩noisy by running M shots on a QPU leading to a statistical error ≤1/ √ M. Assuming perfect knowledge of q, the protocol then needs to \"stretch\" the result by a factor (1 −q)−V , producing an unbiased estimate of ⟨O⟩ideal. However, unfortunately, the statistical error is also stretched, to (1 −q)−V / √ M.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "noisy",
                "protocol",
                "statistical",
                "error",
                "expectation",
                "running",
                "shots",
                "leading",
                "stretch"
            ]
        }
    },
    {
        "id": "520ef4e1-d01f-4d99-b384-26567d58eb31",
        "title": "",
        "chunk_text": "Thus, M ≥ϵ−2(1 −q)−2V shots must be used to 12There are a few subtleties involved in accurately determining the shot overhead of EM protocols. First, there are generically O(γ2V ) corrections in the exponent. Additionally, there may be multiplicative factors which are polynomial in γV . Finally, we work with the active circuit volume as it is an intrinsic property of instances of the problem EVEϵ.",
        "metadata": {
            "author": "",
            "keywords": [
                "protocols",
                "subtleties",
                "involved",
                "accurately",
                "determining",
                "overhead",
                "shots",
                "shot",
                "Finally",
                "Additionally"
            ]
        }
    },
    {
        "id": "3c9dddb8-c383-46fb-886c-8782ce1b7137",
        "title": "",
        "chunk_text": "However, the shot overhead of some EM protocols (e.g., exponential ZNE) depends on the effective circuit volume, Veff = γ−1 log(⟨O⟩ideal / ⟨O⟩noisy), which corresponds not to a subset of gates in the circuit, but to the decay of the expectation value due to noise. The latter is generically proportional to the active volume (with an n-independent proportionality constant), but the two can scale differently with n in some cases (see e.g., Ref. [74]).",
        "metadata": {
            "author": "",
            "keywords": [
                "Veff",
                "circuit",
                "ZNE",
                "volume",
                "log",
                "ideal",
                "noisy",
                "protocols",
                "exponential",
                "depends"
            ]
        }
    },
    {
        "id": "e97d329f-df44-463f-bb82-c08b5f8c5615",
        "title": "",
        "chunk_text": "As another example, for EM based on QP distributions, mitigation is usually performed locally, and the relevant volume corresponds to the gates (or gate errors) one chooses to mitigate to insure a negligible bias, see [68, 75, 76]. This is closely related, but not identical, to the active volume. Since Eq. (3) is expressed in terms of the active volume, in methods in which other volumes are relevant, the difference is swallowed into λ.",
        "metadata": {
            "author": "",
            "keywords": [
                "volume",
                "distributions",
                "mitigation",
                "locally",
                "errors",
                "bias",
                "active",
                "gates",
                "gate",
                "based"
            ]
        }
    },
    {
        "id": "bcfb6c32-1b15-4abd-bab1-12588477808b",
        "title": "",
        "chunk_text": "12 4 EVIDENCE AGAINST ASYMPTOTIC QA WITH EM ensure a statistical estimation error at most ϵ. Using the infidelity γ = (1 −4−n)q of the depolarizing channel,13 this can be written as M ≥ϵ−2e2γV/(1−4−n)+O(γ2V ), which demonstrates Eq. (3), with blowup rate λ = 2/(1 −4−n) ∈(2, 8/3].",
        "metadata": {
            "author": "",
            "keywords": [
                "EVIDENCE",
                "ASYMPTOTIC",
                "ensure",
                "statistical",
                "estimation",
                "error",
                "depolarizing",
                "infidelity",
                "written",
                "demonstrates"
            ]
        }
    },
    {
        "id": "9b5bd08a-c6ce-4eef-a9c0-d5701f90b80d",
        "title": "",
        "chunk_text": "Though this toy model is over-simplified, it seems to capture an essential point - the need to effectively stretch the output by an exponentially large factor, in order to combat the effect of exponential decay due to noise. This stretch increases the variance of the output exponentially, implying a similar increase in the number of shots, which is needed in order to meet the required statistical error with such a large variance.",
        "metadata": {
            "author": "",
            "keywords": [
                "order",
                "output",
                "over-simplified",
                "point",
                "factor",
                "noise",
                "stretch",
                "exponentially",
                "large",
                "toy"
            ]
        }
    },
    {
        "id": "c0bc76a2-55c4-4fe7-bfb8-d20bc2e46663",
        "title": "",
        "chunk_text": "Another toy EM protocol that one may consider is given by an idealized post-selection that manages to reject all erred shots [41]. In this case only a fraction (1 −q)V of shots is maintained, leading to a sampling overhead (1 −q)−V , which again reproduces Eq. (3), now with λ = 1/(1 −4−n). The above arguments have led researchers to seek for a lower bound along the lines of Eq. (3) that may hold for any EM method. We survey those below.",
        "metadata": {
            "author": "",
            "keywords": [
                "shots",
                "toy",
                "protocol",
                "idealized",
                "post-selection",
                "manages",
                "reject",
                "erred",
                "fraction",
                "maintained"
            ]
        }
    },
    {
        "id": "45a34b19-9847-4047-92b7-27d26c065c98",
        "title": "",
        "chunk_text": "4.2 Towards general exponential lower bounds on the sampling overhead There are a number of results providing lower bounds on the required shot number that hold for general, rather than specific, EM methods [1–4]. Before we survey these results, we note that known EM protocols [41], as well as the lower bounds of Ref. [1–4], show that one may avoid the exponential scaling of Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "bounds",
                "lower",
                "general",
                "number",
                "specific",
                "methods",
                "results",
                "Ref",
                "sampling",
                "overhead"
            ]
        }
    },
    {
        "id": "86bccedc-104e-471e-8149-2490bb38f892",
        "title": "",
        "chunk_text": "(3) only at the expense of a significant bias, that is, a large estimation error that persists even with infinitely many shots.14 Such biases are notoriously difficult to bound, often leading to EM protocols with no accuracy guarantee; a situation which is especially problematic in the context of computational problems that are not efficiently verifiable.",
        "metadata": {
            "author": "",
            "keywords": [
                "bias",
                "bound",
                "guarantee",
                "verifiable",
                "expense",
                "significant",
                "large",
                "estimation",
                "error",
                "persists"
            ]
        }
    },
    {
        "id": "dbaf882c-42db-4f12-8e50-d9fbb1edb982",
        "title": "",
        "chunk_text": "In the remainder of this paper we restrict attention to EM protocols that produce a negligible bias b ≪ϵ for the circuits in question.15 This includes (i) unbiased EM protocols, where the bias is rigorously guaranteed to be negligible for any circuit and observable; and (ii) heuristic EM protocols, where no such guarantee exists, but nevertheless the bias is still negligible in particular cases.16 We now survey the results of Ref. [1–4], for EM protocols with negligible bias.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ref",
                "bias",
                "protocols",
                "negligible",
                "includes",
                "unbiased",
                "observable",
                "heuristic",
                "exists",
                "remainder"
            ]
        }
    },
    {
        "id": "c9f304f1-0765-4a91-9697-e1fce1a00f08",
        "title": "",
        "chunk_text": "These results are derived under a general definition of EM protocols provided in Ref. [1], the essence of which is the exclusion of adaptive quantum operations. In a nutshell, a lower bound along the lines of Eq. (3) (with λ a constant independent of n) is not known to hold for all circuits and observables; in fact, recent work suggests the existence of fine-tuned counter examples. Nevertheless, Eq. (3) does seem to hold very generally.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ref",
                "results",
                "derived",
                "general",
                "definition",
                "protocols",
                "provided",
                "hold",
                "operations",
                "essence"
            ]
        }
    },
    {
        "id": "96a53597-e936-4f36-b643-30592ba9c40d",
        "title": "",
        "chunk_text": "To the best of our knowledge, the strongest known lower bounds on the number of shots M that hold for any circuit, observable and EM protocol, are exponential in the circuit depth D as opposed to the volume V [2–4].",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "knowledge",
                "observable",
                "protocol",
                "strongest",
                "lower",
                "bounds",
                "number",
                "shots",
                "hold"
            ]
        }
    },
    {
        "id": "3e882e2c-631a-4f48-bee6-986372641068",
        "title": "",
        "chunk_text": "In particular, assuming (i) a local-depolarizing error model, (ii) a trace-less observable O, and (iii) a large-enough ideal expectation value | ⟨O⟩ideal | > 2ϵ; the number of shots M required by any EM protocol (with negligible bias) to reach a statistical error at most ϵ in estimating the expectation value ⟨O⟩C for any observable O and circuit C, satisfies M ≥1 ϵ2 eλγD.",
        "metadata": {
            "author": "",
            "keywords": [
                "assuming",
                "iii",
                "eλγD",
                "observable",
                "expectation",
                "error",
                "ideal",
                "model",
                "protocol",
                "bias"
            ]
        }
    },
    {
        "id": "f5f63031-316f-415a-ae6b-4b9b2b339280",
        "title": "",
        "chunk_text": "(4) This result is based on the known decay of the output state towards the maximally mixed state, which, assuming a local depolarizing model, decreases exponentially with γD [78–81]. The works [3, 4] further demonstrated the existence of circuits for which the number of shots M for any EM protocol must be exponential in the total circuit volume nD/2 ≥V and not only in D. By 13We work with the ‘entanglement infidelity’, as opposed to the ‘average gate infidelity’ [77].",
        "metadata": {
            "author": "",
            "keywords": [
                "state",
                "assuming",
                "model",
                "decreases",
                "result",
                "based",
                "decay",
                "output",
                "maximally",
                "mixed"
            ]
        }
    },
    {
        "id": "9a529c6c-631f-4ae8-bb06-3ae0fca6e3c0",
        "title": "",
        "chunk_text": "14This is the behavior of e.g., polynomial ZNE (with a low-degree polynomial) which requires a small sampling overhead, but can lead to significant biases unless γV ≪1 [42]. 15There’s no problem allowing for a small, but non-negligible, bias, say b < ϵ/2. This effectively replaces ϵ by ϵ/2 in Eq. (3), as well as in Eq. (14) below. In fact, trading bias for error bar in a controlled manner is an important aspect of designing practical EM protocols.",
        "metadata": {
            "author": "",
            "keywords": [
                "ZNE",
                "polynomial",
                "small",
                "overhead",
                "behavior",
                "low-degree",
                "requires",
                "sampling",
                "lead",
                "significant"
            ]
        }
    },
    {
        "id": "630b0a54-6a65-4af8-b0f6-18145b33f850",
        "title": "",
        "chunk_text": "16An example for the first type, namely unbiased protocols, is EM protocols based on QP distributions that rely on a good-enough characterization of error channel. An example for heuristic EM protocols in which the bias is negligible for specific cases, is exponential ZNE, where the bias vanishes for Clifford circuits with Pauli errors, but not generally.",
        "metadata": {
            "author": "",
            "keywords": [
                "protocols",
                "type",
                "channel",
                "unbiased",
                "based",
                "distributions",
                "rely",
                "good-enough",
                "characterization",
                "ZNE"
            ]
        }
    },
    {
        "id": "d98df249-fcdd-4c21-b276-611fc921dc04",
        "title": "",
        "chunk_text": "13 4 EVIDENCE AGAINST ASYMPTOTIC QA WITH EM limiting their circuit construction to the connectivity of a d-dimensional lattice, Reference [4] further showed compelling evidence that, for the above circuits, it is the active volume (or ‘light cone’) that controls the shot overhead of EM, as opposed to the total circuit volume. We describe these results, which are closely related to the above global depolarizing toy model, in more detail in Appendix A.1.",
        "metadata": {
            "author": "",
            "keywords": [
                "Reference",
                "volume",
                "EVIDENCE",
                "ASYMPTOTIC",
                "circuit",
                "lattice",
                "light",
                "cone’",
                "limiting",
                "construction"
            ]
        }
    },
    {
        "id": "bd1856ec-ce9e-486a-b449-ef754a07f584",
        "title": "",
        "chunk_text": "Despite the above results, compelling evidence that Eq. (3) is violated for a different family of circuits, for restricted input states and observables, was recently presented in Ref. [74]. In the examples discussed in [74] the behavior of the shot overhead is exponential in D and not in V .",
        "metadata": {
            "author": "",
            "keywords": [
                "results",
                "compelling",
                "evidence",
                "Ref",
                "circuits",
                "observables",
                "violated",
                "family",
                "restricted",
                "input"
            ]
        }
    },
    {
        "id": "e48f0c4c-40ad-4408-b44a-5f149cf39c45",
        "title": "",
        "chunk_text": "The authors consider certain 2d Trotter circuits, where n ∼D2 and V ∼nD ∼D3, and observe that for very particular initial states and observables, the decay of the observable due to errors can scale with depth, as e−Ω(γD), rather than with volume. Accordingly, EM methods with a sampling overhead of only eO(γD) may in principle be used in these particular cases. We conclude that while Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "Trotter",
                "circuits",
                "depth",
                "volume",
                "authors",
                "observe",
                "initial",
                "states",
                "decay",
                "due"
            ]
        }
    },
    {
        "id": "9d6f8034-ff28-448b-b582-d410fe364638",
        "title": "",
        "chunk_text": "(3) seems to hold very broadly, it fails to hold in all cases with V in the exponent; it does hold generally with D in place of V . This is a strong lower bound only for circuits whose depth D grows super-logarithmically with n. We now proceed to deduce the negative implications of such exponential lower bounds on the prospects for asymptotic QA with EM.",
        "metadata": {
            "author": "",
            "keywords": [
                "hold",
                "broadly",
                "exponent",
                "lower",
                "fails",
                "cases",
                "generally",
                "place",
                "strong",
                "circuits"
            ]
        }
    },
    {
        "id": "35168f23-1809-4766-bb1f-61e23ade576c",
        "title": "",
        "chunk_text": "4.3 EM with exponential overheads cannot enable exponential asymptotic QA It is easy to see that in cases where the EM shot overhead scales according to Eq. (3), exponential asymptotic QA is ruled out. Furthermore, for any negligibly-biased EM protocol, applied to any circuit and observable with D > n, exponential asymptotic QA is ruled out due to the general lower bound in Eq. (4).",
        "metadata": {
            "author": "",
            "keywords": [
                "asymptotic",
                "exponential",
                "ruled",
                "enable",
                "easy",
                "cases",
                "shot",
                "scales",
                "overheads",
                "overhead"
            ]
        }
    },
    {
        "id": "d52d449b-8286-46c7-b1c3-506f9f364d59",
        "title": "",
        "chunk_text": "Let Tc be the time required to classically solve the expectation value estimation problem EVEϵ using the best available algorithm, and TEM the time to solve it on a quantum processor using an EM protocol; we claim Corollary 1 (Exponentially scaling EM cannot provide exponential asymptotic QA) Consider an EM protocol, and a family of circuits and observables for which one of the following two conditions hold: (i) The exponential lower bound in V , Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "protocol",
                "time",
                "Corollary",
                "Exponentially",
                "solve",
                "exponential",
                "TEM",
                "algorithm",
                "hold",
                "required"
            ]
        }
    },
    {
        "id": "f56f3ca9-c80e-44ff-a3cc-41bcc5bca3d4",
        "title": "",
        "chunk_text": "(3), is satisfied with λγ ≥γ for some n-independent bound γ ∈(0, 1], or (ii) the depths of the circuits satisfy D ≥n, and we also have that the conditions for the exponential lower bound in D, Eq. (4), hold; namely, the circuit is affected by a local depolarizing model, the observable O is trace-less, and its ideal expectation value is non-negligible, | ⟨O⟩ideal | > 2ϵ. In either case we have that the classical run time is polynomially bounded by the EM run time: Tc = O(T 1/γ EM).",
        "metadata": {
            "author": "",
            "keywords": [
                "bound",
                "satisfied",
                "n-independent",
                "depths",
                "satisfy",
                "conditions",
                "exponential",
                "lower",
                "ideal",
                "run"
            ]
        }
    },
    {
        "id": "cd1f702b-a69e-451c-b23a-86d20bb6aba7",
        "title": "",
        "chunk_text": "(5) Since the classical run time Tc is at most polynomial (with degree 1/γ) in the EM run time TEM, any asymptotic QA with EM is at most polynomial. In particular, there is no exponential asymptotic QA of EM over classical computation. Proof: We prove the first case, the second one is similar. First, we translate the shot number in Eq. (3) to a lower bound on the run time of EM for a quantum circuit of depth D, TEM = Ω(DM) = Ω \u0012 1 ϵ2 DeλγV \u0013 .",
        "metadata": {
            "author": "",
            "keywords": [
                "polynomial",
                "TEM",
                "asymptotic",
                "run",
                "time",
                "classical",
                "degree",
                "computation",
                "Proof",
                "exponential"
            ]
        }
    },
    {
        "id": "c54cb24a-4391-4144-aad5-0a78badc7476",
        "title": "",
        "chunk_text": "(6) Note that we use here the total circuit depth over all quantum circuits in the EM protocol to bound the run time,17 without including the classical run time which will of course only increase the lower bound. 17We comment here on the relation of this simple bound to realistic experimental settings. In experiments, one can bound TEM ≥tsM, where ts is the shot time, which can itself be bounded as ts ≥tlD, where tl is the time per circuit layer.",
        "metadata": {
            "author": "",
            "keywords": [
                "Note",
                "run",
                "bound",
                "time",
                "total",
                "depth",
                "quantum",
                "protocol",
                "including",
                "classical"
            ]
        }
    },
    {
        "id": "b7414be5-f277-455b-b205-59dca99c1baf",
        "title": "",
        "chunk_text": "The lower bound for the shot time assumes that the relevant QPU can parallelize all gates appearing in each circuit layer, and accounts only for the time to implement these layers. Limited parallelization, or additional delays due to e.g., state preparation and measurement, will increase the shot time. Similarly, the bound TEM ≥tsM accounts only for the physical time to implement the quantum operations in each shot.",
        "metadata": {
            "author": "",
            "keywords": [
                "time",
                "QPU",
                "shot",
                "layer",
                "layers",
                "accounts",
                "implement",
                "lower",
                "assumes",
                "relevant"
            ]
        }
    },
    {
        "id": "19022c0c-91e7-433b-88b7-1d447422856f",
        "title": "",
        "chunk_text": "In practice, current QPUs suffer significant additional delays (‘circuit time’), due to the loading of circuit instructions onto classical control electronics. 14 4 EVIDENCE AGAINST ASYMPTOTIC QA WITH EM We can now compare this run time to that of the best available classical simulation.",
        "metadata": {
            "author": "",
            "keywords": [
                "practice",
                "current",
                "delays",
                "time’",
                "due",
                "electronics",
                "circuit",
                "EVIDENCE",
                "classical",
                "QPUs"
            ]
        }
    },
    {
        "id": "670a9145-d039-4448-a510-cfa99a216e7d",
        "title": "",
        "chunk_text": "The run time of that would be at most that of the simplest classical simulation of quantum circuits, namely, state-vector simulation, which would require Tc = O(V 2n), (7) floating-point operations, for an ideal n-qubit quantum circuit including V 2-qubit gates; see details in Sec. 5.2. Further note that V is bounded by the maximal number of 2-qubit gates in the circuit, V ≤nD/2, where D is the circuit depth and n/2 is the maximal number of 2-qubit gates per layer.",
        "metadata": {
            "author": "",
            "keywords": [
                "Sec",
                "quantum",
                "simulation",
                "gates",
                "circuit",
                "state-vector",
                "floating-point",
                "operations",
                "run",
                "time"
            ]
        }
    },
    {
        "id": "27fe261b-dc15-4614-a67a-4d99809076be",
        "title": "",
        "chunk_text": "Equations (6) and (7) then together imply the desired relation: Using ϵ < 1, V ≥n (see Remark 5) and en > n2n (for, say, n > 10), the corollary follows from ϵ−2DeλγV ≥DeγV ≥Deγn > D(n2n)γ > (Dn2n)γ > (V 2n)γ. □ Remark 6 (Role of the lower bound γ) The requirement that λγ ≥γ may be refined to separate n- independent lower bounds on γ and λ. The first lower bound is a very realistic assumption, since there is no experimental indication for error rates decreasing with the number of qubits.",
        "metadata": {
            "author": "",
            "keywords": [
                "Deγn",
                "Remark",
                "Equations",
                "DeγV",
                "lower",
                "relation",
                "imply",
                "desired",
                "corollary",
                "bound"
            ]
        }
    },
    {
        "id": "efa35ed9-b4c5-4e84-a99d-6e2a44727d60",
        "title": "",
        "chunk_text": "In fact, error rates tend to increase with the number of qubits [82], since maintaining high quality at scale is a more challenging engineering task. The second lower bound, on λ, is meant to exclude the known examples in which the sampling overhead is exponential in D instead of V (see Subsection 4.2). As we expect Eq. (3) to hold generically (with λ bounded from below by a constant independent of n), we expect that, generically, EM cannot provide exponential asymptotic QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "fact",
                "error",
                "qubits",
                "task",
                "rates",
                "tend",
                "increase",
                "number",
                "maintaining",
                "high"
            ]
        }
    },
    {
        "id": "8c38e8ee-3631-42b0-b46c-400677e97750",
        "title": "",
        "chunk_text": "Remark 7 (What about polynomial QA?) Corollary 1 does not exclude polynomial QA using EM. However, we note that classical simulation becomes more efficient compared to EM (namely, the upper bound of Eq. (5) becomes less tight), the larger V is relative to n, such that polynomial asymptotic QA is only possible when V = O(n), namely for constant depth circuits.",
        "metadata": {
            "author": "",
            "keywords": [
                "Remark",
                "polynomial",
                "Corollary",
                "exclude",
                "tight",
                "circuits",
                "note",
                "classical",
                "simulation",
                "efficient"
            ]
        }
    },
    {
        "id": "9bb7c68e-d072-42b7-a66c-34de3b2c0576",
        "title": "",
        "chunk_text": "In the noiseless setting, constant depth circuits are conjectured to provide exponential asymptotic QA for sampling problems, e.g., in the model of Instantaneous Quantum Polytime (IQP) [83–87]. We pose here as an open problem whether EM for expectation values of heavy weight tensor product observables measured at the end of constant depth quantum circuits may lead to polynomial asymptotic QAs. The results in this section still do not rule out exponential asymptotic QA using EM in special cases.",
        "metadata": {
            "author": "",
            "keywords": [
                "IQP",
                "Polytime",
                "Instantaneous",
                "asymptotic",
                "Quantum",
                "constant",
                "depth",
                "setting",
                "circuits",
                "exponential"
            ]
        }
    },
    {
        "id": "b213dde0-10ca-4581-b059-0184c44a8374",
        "title": "",
        "chunk_text": "We next describe a recent result which proves a no-go theorem in a more general setting. 4.4 No-go for exponential asymptotic QA The assumptions stated in Corollary 1 (namely, that Eq. (3) holds or that D ≥n) were needed because of the current limitations of rigorous lower bounds on the shot overhead of EM, as described in Sec. 4.2.",
        "metadata": {
            "author": "",
            "keywords": [
                "no-go",
                "setting",
                "Corollary",
                "describe",
                "recent",
                "result",
                "proves",
                "theorem",
                "general",
                "Sec"
            ]
        }
    },
    {
        "id": "6780e80c-2a9f-47b0-bc3c-f5551a030c91",
        "title": "",
        "chunk_text": "In this section we describe recent work that excludes exponential asymptotic QA without relying on such assumptions, and which holds for every EM protocol, circuit and observable, but only on average over input states [5]. The main result of Ref. [5] is a classical algorithm for approximating expectation values in any noisy quantum circuit (up to error ϵ′).",
        "metadata": {
            "author": "",
            "keywords": [
                "assumptions",
                "protocol",
                "observable",
                "states",
                "Ref",
                "section",
                "describe",
                "recent",
                "work",
                "excludes"
            ]
        }
    },
    {
        "id": "43dc3a4f-e0b3-4acd-9e90-e3edecdf3ed3",
        "title": "",
        "chunk_text": "The algorithm’s run time is O((1/ϵ′) ˜O(1/γ2)), which is polynomial in the required accuracy ϵ′, with degree ˜O(1/γ2); albeit a large degree, this is a polynomial algorithm. Notably, this performance guarantee holds for any fixed circuit and observable, improving over previous work [88] which provided a similar result but only on average over random circuits. Importantly, the accuracy guarantee of Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "degree",
                "algorithm",
                "polynomial",
                "albeit",
                "run",
                "time",
                "required",
                "large",
                "accuracy",
                "Notably"
            ]
        }
    },
    {
        "id": "454d3da4-8b34-41d3-97f9-290b42195a0d",
        "title": "",
        "chunk_text": "[5] does not hold for any input to the quantum circuit, but only on average over computational basis input states. Ref. [5] use their algorithm to provide limitations on any EM protocol for the problem of EVEϵ, based on the following idea. They use their classical algorithm for simulating noisy circuits, in order to simulate each of the M shots of the EM protocol.",
        "metadata": {
            "author": "",
            "keywords": [
                "input",
                "states",
                "hold",
                "quantum",
                "average",
                "computational",
                "basis",
                "protocol",
                "algorithm",
                "Ref"
            ]
        }
    },
    {
        "id": "ab4430c7-e2bd-4481-9381-fa92e9f7dd8a",
        "title": "",
        "chunk_text": "In order to arrive at total error ϵ in the final estimation of the expectation value, the authors run their classical simulation algorithm for each of the M shots with required accuracy ϵ′ = O(ϵ/M). This leads to a total classical run time Tc = O((M/ϵ) ˜O(1/γ2)) = O((TEM/ϵ) ˜O(1/γ2)). (8) 15 5 USEFUL FINITE QAS EXPECTED IN THE NEAR FUTURE USING EM Notably, a lower bound which is significantly weaker than Eq. (5), but still a polynomial.",
        "metadata": {
            "author": "",
            "keywords": [
                "total",
                "run",
                "classical",
                "TEM",
                "order",
                "arrive",
                "error",
                "final",
                "estimation",
                "expectation"
            ]
        }
    },
    {
        "id": "91c40388-d715-4e39-b742-8864ebe3e270",
        "title": "",
        "chunk_text": "Thus, whenever the number of shots M in the EM protocol for EVEϵ is polynomial, Reference [5] constructs a simulation of EVEϵ for the ideal quantum circuit which takes polynomial time. We stress that the guarantee for the error to be smaller than ϵ does not hold for any input state, but only on average over all inputs.",
        "metadata": {
            "author": "",
            "keywords": [
                "Reference",
                "EVEϵ",
                "polynomial",
                "constructs",
                "time",
                "number",
                "shots",
                "protocol",
                "simulation",
                "ideal"
            ]
        }
    },
    {
        "id": "675a6a9f-1b5c-4b0f-86e5-2f2e6f27abe5",
        "title": "",
        "chunk_text": "Thus, Reference [5] shows that EM alone cannot lead to exponential asymptotic QA (or in fact to any non-polynomial asymptotic QA), for the variant of the problem EVEϵ in which ϵ is the root-mean-squared error over all 2n input states (see Sec. 3).18 We note that this no-go result still does not completely rule out exponential QA using EM, due to this average over all inputs to the circuits involved.",
        "metadata": {
            "author": "",
            "keywords": [
                "Reference",
                "Sec",
                "asymptotic",
                "shows",
                "error",
                "states",
                "exponential",
                "lead",
                "fact",
                "non-polynomial"
            ]
        }
    },
    {
        "id": "927480c1-5507-453b-9915-2d0c73818881",
        "title": "",
        "chunk_text": "This leaves a small crack in the door for exponential asymptotic QA to be achievable using EM when restricted to a special small set of input states, that will not significantly affect the average over inputs; in line with the recent examples of Ref. [74], suggesting a violation of Eq. (3) with fine-tuned input states. We do not concern ourselves further with this highly specific case; the main message is that, generically, EM alone cannot enable exponential asymptotic QA.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ref",
                "small",
                "states",
                "asymptotic",
                "input",
                "leaves",
                "crack",
                "door",
                "achievable",
                "restricted"
            ]
        }
    },
    {
        "id": "13cbd710-f58f-41da-b1e8-d5a46a6e5e49",
        "title": "",
        "chunk_text": "To summarize, we see that EM cannot on its own enable generic exponential asymptotic QAs. In light of this, and the immense importance of exponential asymptotic QAs in motivating the whole field of quantum computation, one must ask – why bother with EM at all? 5 Useful finite QAs expected in the near future using EM We now explain how, despite the lessons from Sec. 4, EM does in fact provide a viable path to QA. The point is exactly the distinction between exponential asymptotic QA, which Sec.",
        "metadata": {
            "author": "",
            "keywords": [
                "asymptotic",
                "exponential",
                "QAs",
                "Sec",
                "summarize",
                "enable",
                "generic",
                "computation",
                "light",
                "immense"
            ]
        }
    },
    {
        "id": "612b6e34-7bd5-4b0f-bc64-9fe5b5ec3aa6",
        "title": "",
        "chunk_text": "4 argues cannot be achieved with EM alone, and finite QA. We argue here that EM is an extremely promising path to finite QAs, and is in fact expected to enable such advantages in the very near future – much earlier than EC. Furthermore, based on the same reasoning which we will outline in this section, we will see in Sec. 6 that though EM cannot provide exponential QA on its own, it can in fact crucially help in bringing it much earlier than would be possible without EM, namely with EC alone.",
        "metadata": {
            "author": "",
            "keywords": [
                "finite",
                "achieved",
                "earlier",
                "fact",
                "Sec",
                "argues",
                "argue",
                "QAs",
                "future",
                "extremely"
            ]
        }
    },
    {
        "id": "1231f224-d902-4524-8203-ed1e7b8eb1a3",
        "title": "",
        "chunk_text": "The starting point is a very important observation regarding the exponent in the lower bound on the sampling overhead of EM, Eq. (3). The power of the exponent in this lower bound contains a very small constant - the infidelity per gate γ. Thus, though the sampling overhead indeed grows exponentially, it is a very mild exponential growth. Current values of γ are in the range 10−3 −10−2, and may reach 10−4 within the next few years [18, 89].",
        "metadata": {
            "author": "",
            "keywords": [
                "exponent",
                "lower",
                "bound",
                "sampling",
                "starting",
                "point",
                "important",
                "observation",
                "overhead",
                "constant"
            ]
        }
    },
    {
        "id": "00919134-aeec-44f1-a460-570f646a1baf",
        "title": "",
        "chunk_text": "Closely related, the degree 1/γ of the polynomial connecting the complexity of classically simulating quantum circuits and the complexity of EM protocols (Corollary 1), is very large, currently in the range 102 −103, and possibly 104 in the near term. Thus, while the classical run time is indeed only polynomial in the quantum run time as is derived in Corollary 1, this polynomial classical computation could still be tremendously expensive compared to the quantum one.",
        "metadata": {
            "author": "",
            "keywords": [
                "complexity",
                "Corollary",
                "quantum",
                "polynomial",
                "Closely",
                "related",
                "degree",
                "protocols",
                "large",
                "range"
            ]
        }
    },
    {
        "id": "17535aa6-4f87-40d8-9f56-4b12290d9a79",
        "title": "",
        "chunk_text": "The upshot is that though EM is not expected to lead to exponential QA (and in fact not even polynomial, except possibly for very special cases of constant depth circuits, as discussed at the end of Sec. 4) it does offer a very challenging fight, for shallow circuits, to the classical competition, due to this large power of 1/γ. This is what leaves a slack for EM to provide very significant finite QAs.",
        "metadata": {
            "author": "",
            "keywords": [
                "Sec",
                "circuits",
                "polynomial",
                "upshot",
                "expected",
                "lead",
                "exponential",
                "fact",
                "possibly",
                "special"
            ]
        }
    },
    {
        "id": "c84c9b90-14a2-4ddd-9fed-28c8d5db836d",
        "title": "",
        "chunk_text": "In this section we clarify the resulting potential benefits of using EM in real world quantum computations, in two ways. First, in Sec. 5.1 we introduce an important notion, which we term “circuit volume boost” (CVB), that can be used to quantify the benefit of using EM over not using it. In Sec. 5.2, we provide estimation of the finite QAs that can be achieved using EM, for different fidelity values of the hardware.",
        "metadata": {
            "author": "",
            "keywords": [
                "Sec",
                "computations",
                "section",
                "clarify",
                "resulting",
                "potential",
                "real",
                "world",
                "quantum",
                "CVB"
            ]
        }
    },
    {
        "id": "1999fdd3-5bdd-4f2b-a38f-a6e0f4c2a89f",
        "title": "",
        "chunk_text": "18One may notice that we can now turn back to the first question discussed in this section, and ask whether the results of Ref. [5] can be used to deduce the lower bound of Eq. (6) for generic EM protocols. As mentioned above, there are specific counter examples in which this bound does not hold [74]; however, one might expect the lower bound to still hold generically.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ref",
                "section",
                "bound",
                "lower",
                "notice",
                "turn",
                "back",
                "question",
                "discussed",
                "results"
            ]
        }
    },
    {
        "id": "1ef876c6-d93a-4935-91d4-d2dbcf9bc36a",
        "title": "",
        "chunk_text": "In Appendix A.2 we show that such a line of reasoning can indeed be applied, to yield a lower bound which in some cases is stronger than the exponential in D lower bound, however it is weaker than Eq. (6). 16 5 USEFUL FINITE QAS EXPECTED IN THE NEAR FUTURE USING EM 5.1 Circuit Volume Boosts We introduce a useful definition for comparing the performance of quantum computation with and without EM, which we call circuit volume boost (or CVB in short).",
        "metadata": {
            "author": "",
            "keywords": [
                "Appendix",
                "lower",
                "bound",
                "applied",
                "Volume",
                "show",
                "line",
                "reasoning",
                "yield",
                "cases"
            ]
        }
    },
    {
        "id": "73c14a5b-4196-4f9c-908d-95d94288468a",
        "title": "",
        "chunk_text": "The CVB captures the factor by which one can increase the volume of quantum circuits being run using EM, compared to the circuit volumes available without EM. In fact, the CVB can be used for comparing the performance of any two methods for executing quantum circuits. Recall that the number of shots required to ensure accuracy 1 −ϵ in the ideal (noiseless) computation is ϵ−2, since in this case the error is entirely statistical. In EM, we allow a larger shot budget.",
        "metadata": {
            "author": "",
            "keywords": [
                "CVB",
                "quantum",
                "circuits",
                "volume",
                "volumes",
                "compared",
                "captures",
                "factor",
                "increase",
                "run"
            ]
        }
    },
    {
        "id": "06d19f60-134d-486a-b20d-b408806f9d61",
        "title": "",
        "chunk_text": "We find it convenient to write the allowed shot budget as a multiple of the number of shots required by the ideal computation for the same accuracy, M = R/ϵ2, (9) with R > 1. We thus introduce the allowed shot overhead R := Mϵ2. In the discussion below, we will study the behavior of EM for fixed values of the allowed shot overhead R. With this convention, we now define the CVB.",
        "metadata": {
            "author": "",
            "keywords": [
                "allowed",
                "shot",
                "accuracy",
                "overhead",
                "find",
                "convenient",
                "write",
                "budget",
                "multiple",
                "number"
            ]
        }
    },
    {
        "id": "a28a02d8-3d91-411a-bd39-51a91f3c2f1c",
        "title": "",
        "chunk_text": "Definition 5.1 Circuit volume boost (CVB) Let VA(ϵ, R) denote the maximal circuit volume that can be achieved with circuit execution method A, given an allowed shot overhead R ≥1, and while meeting a required output accuracy 1 −ϵ. Let VB(ϵ, R) denote the maximal volume possible with circuit execution method B, under the same constraints.",
        "metadata": {
            "author": "",
            "keywords": [
                "CVB",
                "Circuit",
                "denote",
                "Definition",
                "execution",
                "volume",
                "maximal",
                "method",
                "boost",
                "accuracy"
            ]
        }
    },
    {
        "id": "dd0e4463-2d3e-4612-bf09-afbb99cb3393",
        "title": "",
        "chunk_text": "The circuit volume boost of method A over method B, given an allowed shot overhead R and required accuracy 1 −ϵ, is then given by CV B(ϵ, R) = VA(ϵ, R) VB(ϵ, R). (10) This gives a very clear quantification of the benefit of one method over another, in terms of the ratio between the active volumes that the two methods can achieve. We would now like to estimate the circuit volume boost provided by executing circuits using EM, compared to ‘bare’ circuit execution, without EM.",
        "metadata": {
            "author": "",
            "keywords": [
                "method",
                "circuit",
                "volume",
                "accuracy",
                "boost",
                "allowed",
                "shot",
                "overhead",
                "required",
                "volumes"
            ]
        }
    },
    {
        "id": "e33388e7-9c2d-4891-a8e4-94408663488a",
        "title": "",
        "chunk_text": "We first estimate the circuit volume Vbare which can be run without EM, then estimate VEM, and then compare. 5.1.1 Estimating Vbare We do this under the same global-depolarizing toy-model used in Sec. 4, where ⟨O⟩noisy = e−γV ⟨O⟩ideal,19 and ∥O∥op = 1. The bias in the bare computation is given by b = | ⟨O⟩ideal −⟨O⟩noisy | ≤1 −e−γV , and the statistical error is ≤1/ √ M.",
        "metadata": {
            "author": "",
            "keywords": [
                "VEM",
                "Vbare",
                "estimate",
                "noisy",
                "compare",
                "circuit",
                "volume",
                "run",
                "Estimating",
                "Sec"
            ]
        }
    },
    {
        "id": "966efe16-9188-4962-adfa-b09664c4b524",
        "title": "",
        "chunk_text": "Using these bounds, we can ensure that the total error, given by the sum of the statistical error and the bias,20 is at most ϵ, if ϵ = (1 −e−γVbare) + 1/ √ M. (11) Solving for Vbare and using Eq. (9) then gives Vbare = −1 γ log \u0012 1 −ϵ + 1 √ M \u0013 (12) = −1 γ log \u0012 1 −ϵ + ϵ √ R \u0013 ∼ϵ γ \u0012 1 − 1 √ R \u0013 . 19We suppress here the small differences between (1 −q)V = e−γV/(1−4−n)+O(γ2V ) and e−γV . 20One may similarly work with the mean squared error instead of the sum.",
        "metadata": {
            "author": "",
            "keywords": [
                "error",
                "Vbare",
                "γVbare",
                "bounds",
                "sum",
                "ensure",
                "total",
                "statistical",
                "log",
                "Solving"
            ]
        }
    },
    {
        "id": "bceb539c-6942-44b6-a516-8f10dc1aa6f5",
        "title": "",
        "chunk_text": "17 5 USEFUL FINITE QAS EXPECTED IN THE NEAR FUTURE USING EM Note that the bare execution requires a non-trivial allowed shot overhead R > 1 to support a volume Vbare > 0. The reason is that the systematic error takes up part of the total allowed error budget ϵ, leaving ‘less room’ for the statistical error. On the other hand, due to the bias, even if the number of shots M is taken to infinity, there is a hard upper bound on the available volume: Vbare ∼ϵ/γ.",
        "metadata": {
            "author": "",
            "keywords": [
                "FINITE",
                "QAS",
                "EXPECTED",
                "FUTURE",
                "Note",
                "Vbare",
                "error",
                "allowed",
                "bare",
                "execution"
            ]
        }
    },
    {
        "id": "6ca8ae95-28f3-4310-81cb-8ae810c822b4",
        "title": "",
        "chunk_text": "(13) This upper bound is particularly strict in the high accuracy (small ϵ) regime. Equation (13) is a good rule of thumb for the maximal circuit volume possible without EM. 5.1.2 Estimating VEM Let us now compute the maximal active circuit volume VEM possible with EM. We assume here that there’s no systematic error - this is the case, e.g., when performing EM based on QP distributions and assuming an exact characterization. However, the statistical error is the bottle neck - following Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "regime",
                "accuracy",
                "small",
                "VEM",
                "upper",
                "bound",
                "strict",
                "high",
                "maximal",
                "circuit"
            ]
        }
    },
    {
        "id": "7cfffdd6-27ab-44dc-8675-50574854e2c3",
        "title": "",
        "chunk_text": "(3), the statistical error grows exponentially with the circuit volume, but with a small pre-factor γ, the infidelity per gate: ϵ = 0 + q eλγVEM /M. (14) Solving for VEM we get, VEM = 1 γ log(ϵ2M) λ = 1 γ log R λ . (15) As opposed to Vbare, this is independent of ϵ but is only a function of R. 5.1.3 Estimating the circuit volume boost Given the above two estimates, Eq. (12) and Eq. (15), the CVB is given by CV B(ϵ, R) = VEM Vbare ∼1 ϵ log R λ(1 −1/ √ R) .",
        "metadata": {
            "author": "",
            "keywords": [
                "VEM",
                "Vbare",
                "log",
                "circuit",
                "gate",
                "eλγVEM",
                "volume",
                "statistical",
                "error",
                "grows"
            ]
        }
    },
    {
        "id": "3d4169ea-7a22-4c25-a8d3-6649d8cc4ca6",
        "title": "",
        "chunk_text": "(16) Note that the CVB is independent of the infidelity γ! The function log(R)/(1 −1/ √ R) depends only weakly on R, for example for allowed shot overhead R in the range [2, 109] it takes values in the range ≈[2, 20].21 As described in Sec. 4, the blowup rate λ is a constant of order 1. Thus, an order of magnitude estimate for the CVB due to EM is CV B(ϵ, R) ∼1–10 ϵ . (17) The important feature is that the CV B scales like ∼1/ϵ (see Fig.",
        "metadata": {
            "author": "",
            "keywords": [
                "Note",
                "CVB",
                "range",
                "independent",
                "infidelity",
                "Sec",
                "order",
                "Fig",
                "log",
                "depends"
            ]
        }
    },
    {
        "id": "8dda311b-87ac-4e6c-baf0-529e74520ab4",
        "title": "",
        "chunk_text": "1) meaning that the higher the required accuracy is (smaller ϵ), the larger the CV B. In particular, chemistry applications usually require reaching ‘chemical accuracy’, which translates to ϵ ∼10−3 [90]. As an example, consider e.g., λ = 2 and a mild overhead R = 10. This gives CV B > 10 for 85% accuracy; a CV B > 100 is obtained for 99% accuracy; and a CV B > 1000 is obtained for 99.9% accuracy.",
        "metadata": {
            "author": "",
            "keywords": [
                "accuracy",
                "meaning",
                "smaller",
                "higher",
                "required",
                "larger",
                "obtained",
                "chemistry",
                "reaching",
                "chemical"
            ]
        }
    },
    {
        "id": "e03bd3f0-28b8-4d8b-ba7c-31dc6380a285",
        "title": "",
        "chunk_text": "21Shot overheads as high as 109 are reasonable in superconducting-qubit platforms, where gate times are of the order of tens of nanoseconds. 18 5 USEFUL FINITE QAS EXPECTED IN THE NEAR FUTURE USING EM 75 80 85 90 95 100 101 102 103 Accuracy 1-ϵ [%] CVB=VEM/Vbare R=10 R=103 R=109 Figure 1: Circuit volume boost (CVB) due to unbiased error mitigation with blow up rate λ = 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "CVB",
                "overheads",
                "platforms",
                "nanoseconds",
                "Accuracy",
                "VEM",
                "Figure",
                "high",
                "reasonable",
                "superconducting-qubit"
            ]
        }
    },
    {
        "id": "e0502adc-ccb0-4869-8e5a-7c79992fc377",
        "title": "",
        "chunk_text": "As the allowed inaccuracy ϵ →0, the maximal volume possible without EM vanishes, while the maximal volume possible with unbiased EM is independent of ϵ, given the same allowed shot overhead R for both circuit execution methods. 5.2 Predictions for finite QAs enabled using EM alone Given the impressive expected circuit volume boosts described in Sec. 5.1, what can be said about the expected actual values of V , the volumes of the quantum circuits, to be enabled by EM in the near future?",
        "metadata": {
            "author": "",
            "keywords": [
                "maximal",
                "allowed",
                "volume",
                "vanishes",
                "methods",
                "circuit",
                "inaccuracy",
                "unbiased",
                "independent",
                "shot"
            ]
        }
    },
    {
        "id": "39d0b4f6-5cfe-4444-ac93-07e9358bc881",
        "title": "",
        "chunk_text": "In this subsection, we will argue that EM acting on devices with γ = 10−3 will already enable achieving finite QA within reasonable QPU time. This is the origin of our assertion in the introduction that finite QA in EVE (as defined in Sec. 2) is to be expected already in the very near future. This prediction relies on two claims: first, we provide estimates of the QPU time for EM as a function of the active volumes with such fidelities.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "finite",
                "subsection",
                "time",
                "argue",
                "acting",
                "devices",
                "enable",
                "achieving",
                "reasonable"
            ]
        }
    },
    {
        "id": "e13d80f5-2c13-4b03-a17a-3ef24504b037",
        "title": "",
        "chunk_text": "According to these estimates, active volumes of over a thousand (natively available on a given QPU) 2-qubit gates are achievable in reasonable time with γ = 10−3. Secondly, we claim that achieving active volume of over a thousand gates for general quantum circuits suffices for finite QA in EVE. This is done by showing that for generic circuits, such active volumes seem to be well-beyond the reach of state of the art HPC.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "active",
                "volumes",
                "thousand",
                "estimates",
                "natively",
                "gates",
                "EVE",
                "achievable",
                "reasonable"
            ]
        }
    },
    {
        "id": "65042335-a9dd-4a1a-b75b-6b1ddef4dc72",
        "title": "",
        "chunk_text": "Most of this subsection is devoted to explaining the analysis that supports this latter claim.",
        "metadata": {
            "author": "",
            "keywords": [
                "claim",
                "subsection",
                "devoted",
                "explaining",
                "analysis",
                "supports"
            ]
        }
    },
    {
        "id": "7dc94e4c-7517-4f6c-be12-1656fdd32e87",
        "title": "",
        "chunk_text": "Figure 2 summarizes the analysis of both the quantum and the classical run time as a function of volume, and indicates where finite QA is expected for two types of quantum hardware platforms: superconducting qubits and trapped ions.22 Note that we consider here the ability of EM to execute generic quantum circuits of a given active volume and geometry faster than the performance of classical HPC for the same active volume and geometry, as marking the point of finite QA.23 5.2.1 Estimates of active volume achievable using EM Similarly to the derivation of Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "volume",
                "active",
                "quantum",
                "geometry",
                "Note",
                "Estimates",
                "classical",
                "finite",
                "HPC",
                "Similarly"
            ]
        }
    },
    {
        "id": "51c53525-c656-4dbd-9a76-d02aec8fabca",
        "title": "",
        "chunk_text": "(17), we can use Eq. (15) to obtain an order of magnitude estimate VEM = log R/λγ ∼(1–10)/γ for the volumes enabled by EM, as a function of the infidelity γ, for a 22In drawing Fig. 2, we assume that both EM and classical simulation have access to the same active volume identification subroutine, and so n and V have the same meaning in the analysis of both. 23 We stress, however, that designing finite QA demonstrations that can be considered as rigorously justified requires further work.",
        "metadata": {
            "author": "",
            "keywords": [
                "VEM",
                "Fig.",
                "log",
                "drawing",
                "subroutine",
                "volumes",
                "volume",
                "obtain",
                "order",
                "magnitude"
            ]
        }
    },
    {
        "id": "7511afb0-096d-4840-9835-b555783d9272",
        "title": "",
        "chunk_text": "In particular, to meet the formal requirements of Definition 2.2, one must choose a specific circuit family In and demonstrate finite QA with respect to this family.",
        "metadata": {
            "author": "",
            "keywords": [
                "Definition",
                "family",
                "meet",
                "formal",
                "requirements",
                "choose",
                "specific",
                "circuit",
                "demonstrate",
                "finite"
            ]
        }
    },
    {
        "id": "8d2d411c-b1f2-4ec3-9ff0-21124a698a35",
        "title": "",
        "chunk_text": "The natural choice of defining In to be the set of all quantum circuits of a given size consisting of native gates (for a given hardware), accompanied with some fixed observable, will likely not suffice, since random (or unstructured) circuit families tend to exhibit exponentially small expectation values with overwhelming probability, making the computational task trivial; see e.g., Ref. [97].",
        "metadata": {
            "author": "",
            "keywords": [
                "Ref",
                "gates",
                "hardware",
                "accompanied",
                "observable",
                "suffice",
                "random",
                "unstructured",
                "probability",
                "making"
            ]
        }
    },
    {
        "id": "e5f92e88-ab6d-459a-84ef-baa7b628eda8",
        "title": "",
        "chunk_text": "Instead, it is required to construct a family of circuits In containing a large number of circuits, such that the variance of the ideal expectation values is non-negligible (in particular, it needs to be larger than the accuracy ϵ that is possible to achieve with EM in reasonable time); this is beyond the scope of the current paper. 19 5 USEFUL FINITE QAS EXPECTED IN THE NEAR FUTURE USING EM reasonable allowed shot overhead R ∈[2, 109].",
        "metadata": {
            "author": "",
            "keywords": [
                "circuits",
                "non-negligible",
                "time",
                "paper",
                "reasonable",
                "required",
                "construct",
                "family",
                "large",
                "number"
            ]
        }
    },
    {
        "id": "b8347180-d58c-4407-8c22-e59cb0a53270",
        "title": "",
        "chunk_text": "For near-term 2-qubit gate infidelities γ ∼10−3, this means VEM ∼103–104. (18) Going beyond such order of magnitude estimates requires specifying a particular EM protocol and QPU, and accurately estimating the required number of shots and distinct circuits required by the protocol, as well as the shot and circuit times of the QPU (as already mentioned in Footnote 17). Figure 2 demonstrates the results of such an analysis, based on QESEM, an unbiased EM protocol introduced in Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "VEM",
                "QPU",
                "near-term",
                "gate",
                "protocol",
                "infidelities",
                "Footnote",
                "required",
                "QESEM",
                "Ref"
            ]
        }
    },
    {
        "id": "0e61d322-fb25-442c-83e6-b0d391d9372d",
        "title": "",
        "chunk_text": "[68]; and with characteristic time scales for current QPUs based on either superconducting-qubits or trapped-ions. The solid colored lines in Fig.",
        "metadata": {
            "author": "",
            "keywords": [
                "trapped-ions",
                "Fig",
                "characteristic",
                "time",
                "scales",
                "current",
                "QPUs",
                "based",
                "superconducting-qubits",
                "solid"
            ]
        }
    },
    {
        "id": "29422496-fddc-483d-8823-71d0a2c7ad1e",
        "title": "",
        "chunk_text": "2 show estimates of the QPU time for QESEM as a function of the active volume, for a required output accuracy 1−ϵ = 95%.24 We see that for both superconducting-qubits and trapped-ions, a 2-qubit gate infidelity γ = 10−3 (green lines) suffices to achieve accurate expectation values from circuits with an active volume of over a thousand 2-qubit gates in reasonable time – a few hours for trapped ions, and under an hour for superconducting qubits.25 We devote the remainder of this section to justify the claim that the ability of EM to produce accurate output from circuits actively involving over a thousand 2-qubit gates in reasonable time suffices for finite QA in EVE, namely suffices to exceed state of the art quantum circuit simulation by classical HPC.",
        "metadata": {
            "author": "",
            "keywords": [
                "thousand",
                "gates",
                "time",
                "suffices",
                "reasonable",
                "EVE",
                "HPC",
                "active",
                "volume",
                "QPU"
            ]
        }
    },
    {
        "id": "c9958f98-c1c2-4282-ba12-917ccec90850",
        "title": "",
        "chunk_text": "We start in Sec. 5.2.2 by considering state-vector simulation, and restrict attention to circuits with a particular geometry to enable comparison to EM. In Sec. 5.2.3 we argue that, for circuits with this geometry, state of the art simulation methods, based on tensor-network contraction, will not provide a significant advantage over the run time of state-vector simulation. We comment on additional classical simulation methods, including approximate methods, in Sec. 5.2.4.",
        "metadata": {
            "author": "",
            "keywords": [
                "Sec",
                "simulation",
                "methods",
                "start",
                "state-vector",
                "circuits",
                "geometry",
                "restrict",
                "attention",
                "enable"
            ]
        }
    },
    {
        "id": "ad83f084-a6a4-40c3-9153-aa0d25e4f566",
        "title": "",
        "chunk_text": "0 500 1000 1500 2000 2500 3000 0.1 1 10 100 Active Volume [#2q gates] Run time [hours] Trapped ions Quantum Advantage 0 500 1000 1500 2000 2500 3000 0.1 1 10 100 Active Volume [#2q gates] Superconducting qubits Quantum Advantage F2 q=99.5% F2 q=99.8% F2 q=99.9% HPC (d = 2, v = 0.1) v 0.05 0.10 0.15 0.20 0.25 0.30 0.35 Figure 2: Predictions for finite QA with EM. Coloured lines indicate the QPU time as a function of active circuit volume, when using QESEM, an unbiased EM method introduced in Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "Advantage",
                "gates",
                "Volume",
                "Quantum",
                "HPC",
                "Figure",
                "Run",
                "Trapped",
                "Superconducting",
                "Predictions"
            ]
        }
    },
    {
        "id": "3a2301e1-0492-432f-bef2-6886f2396c05",
        "title": "",
        "chunk_text": "[68], on QPUs based on superconducting-qubits and trapped-ions, for different 2-qubit gate fidelities F2q = 1 −γ, and requiring 95% output accuracy. Differences between the left and right panels stem from the different time scales in the two types of QPUs. The dashed line estimates the run time of state-of-the-art classical simulation algorithms on HPC hardware, using Eq. (20), with dimension d = 2 and operator spreading velocity v = 0.1, as an example.",
        "metadata": {
            "author": "",
            "keywords": [
                "trapped-ions",
                "gate",
                "fidelities",
                "requiring",
                "output",
                "accuracy",
                "QPUs",
                "based",
                "superconducting-qubits",
                "time"
            ]
        }
    },
    {
        "id": "5c1ec0f1-484f-4f6c-a815-aca072d75263",
        "title": "",
        "chunk_text": "Note that since we measure the active volume in native gates and work with d = 2, the all-to-all connectivity advantage of trapped-ions is not explicitly indicated. Finite QA may be achieved when QESEM’s QPU time is significantly below the dashed line. The purple background shows the velocity v (for d = 2) as a function of the active volume V and classical run time Tc, demonstrating how the dashed line would have looked like for with different choices of the velocity v.",
        "metadata": {
            "author": "",
            "keywords": [
                "active",
                "Note",
                "connectivity",
                "volume",
                "dashed",
                "measure",
                "native",
                "gates",
                "work",
                "advantage"
            ]
        }
    },
    {
        "id": "ffe2f81a-561a-4957-b937-eafbea8683b2",
        "title": "",
        "chunk_text": "24We assume here, for simplicity, that the observable is a single Pauli string, with ideal expectation value ⟨O⟩ideal = 1, and with an effective volume Veff := γ−1 log(⟨O⟩ideal / ⟨O⟩noisy) identical to the active volume V . We refer to Ref. [68] for derivations, more general analytic QPU time estimates, improved estimates based on empirical data, and a comparison to experimental performance.",
        "metadata": {
            "author": "",
            "keywords": [
                "Veff",
                "Ref",
                "log",
                "noisy",
                "Pauli",
                "ideal",
                "volume",
                "assume",
                "simplicity",
                "string"
            ]
        }
    },
    {
        "id": "071cb456-8c9d-407b-bf73-e2a6233bbf30",
        "title": "",
        "chunk_text": "25We consider here EM protocols whose run time is dominated by the required QPU time, with a negligible classical time for pre- and post-processing. It is possible to allow for significant HPC usage in EM, which can reduce the QPU time [91–93]. In such cases one must consider the total run time (or other appropriate resource), including both classical and quantum processing.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "time",
                "pre",
                "post-processing",
                "run",
                "protocols",
                "dominated",
                "required",
                "negligible",
                "classical"
            ]
        }
    },
    {
        "id": "a4c53bd3-d4b9-4c06-990c-8b15a9fe7256",
        "title": "",
        "chunk_text": "20 5 USEFUL FINITE QAS EXPECTED IN THE NEAR FUTURE USING EM 5.2.2 Comparison to classical HPC (1): State vector simulation We consider here the classical complexity of EVE, focusing on finite problem sizes and time scales, as opposed to asymptotics. The world’s top supercomputers can now perform ∼1018 floating-point operations per second (FLOPS) [94].",
        "metadata": {
            "author": "",
            "keywords": [
                "Comparison",
                "HPC",
                "State",
                "EVE",
                "FINITE",
                "QAS",
                "EXPECTED",
                "FUTURE",
                "classical",
                "focusing"
            ]
        }
    },
    {
        "id": "be5f6383-c239-4f1f-a4cc-00712c8e6a2b",
        "title": "",
        "chunk_text": "A classical state-vector simulation of quantum circuits with volume V on n qubits requires 4V 2n complex floating-point operations,26 leading to a run time27 Tc ≥V 2n10−18sec. (19) Equation (19) gives the run time of state vector simulation as a function of both the active volume V and the number of active qubits n. On the other hand, as discussed in Sec. 4, the run time of known EM methods is generically determined solely by the active volume V , as in Eq. (3).",
        "metadata": {
            "author": "",
            "keywords": [
                "volume",
                "run",
                "active",
                "requires",
                "complex",
                "floating-point",
                "leading",
                "simulation",
                "qubits",
                "Equation"
            ]
        }
    },
    {
        "id": "5fdac654-7f39-48c6-ae1b-edec6d46fc47",
        "title": "",
        "chunk_text": "Therefore, in order to compare the two run times, we must fix a functional relation between n and V , by restricting attention to a particular family of circuits, as we next describe. Once a functional relation n(V ) is fixed, it can be plugged into Eq. (19) to derive a classical HPC run time estimate as a function of V , as demonstrated in Fig. 2 (dashed line).",
        "metadata": {
            "author": "",
            "keywords": [
                "functional",
                "relation",
                "circuits",
                "describe",
                "run",
                "order",
                "compare",
                "fix",
                "restricting",
                "attention"
            ]
        }
    },
    {
        "id": "0048df6a-4b4b-47e5-a98b-6a6e34f644eb",
        "title": "",
        "chunk_text": "To demonstrate how a family of circuits with a fixed relation n(V ) may be defined, we consider a (hyper) cubic lattice of qubits in d ≥1 dimensions on which we define a circuit of D layers that is made of identical 2-qubit gates. The gates act on the edges of the lattice, such that each qubit experiences a 2-qubit gate in each of the D circuit layers. In addition, we shall assume that at the end of the circuit single-qubit observable is measured.",
        "metadata": {
            "author": "",
            "keywords": [
                "hyper",
                "circuit",
                "lattice",
                "layers",
                "defined",
                "cubic",
                "dimensions",
                "identical",
                "gates",
                "demonstrate"
            ]
        }
    },
    {
        "id": "e3a7a519-dc25-4803-a124-a618beb992c3",
        "title": "",
        "chunk_text": "In such uniform circuits, it is natural to characterize the active volume V in terms of the operator spreading velocity v ∈[0, 1] [96], This velocity determines the number of active qubits in the support of the operator after evolving through the D circuit layers in the Heisenberg picture. When v = 1, the support of the operator grows by one qubit whenever the operator evolves through a 2-qubit gate that crosses its support.",
        "metadata": {
            "author": "",
            "keywords": [
                "operator",
                "support",
                "active",
                "velocity",
                "Heisenberg",
                "picture",
                "circuits",
                "circuit",
                "uniform",
                "natural"
            ]
        }
    },
    {
        "id": "9c20247f-5c9c-42cb-8776-d129c00c4259",
        "title": "",
        "chunk_text": "In practice, the spreading velocity can be much lower than its maximal value 1, e.g., when the gates in the circuit have small rotation angles. For the above circuit family, the active volume V takes the shape of a d-dimensional pyramid with base area n (the number of active qubits) and height D (the circuit depth), with the velocity v determining the opening angle of the pyramid. A simple geometrical calculation then gives the relation n(V ) = (4vV/cd)cd, with cd = d/(d + 1), see Appendix A.3.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "velocity",
                "practice",
                "spreading",
                "lower",
                "maximal",
                "gates",
                "small",
                "rotation",
                "active"
            ]
        }
    },
    {
        "id": "32ab6df1-8cec-49ec-b8d1-d21d91e6e2a3",
        "title": "",
        "chunk_text": "Substituting into Eq. (19), we get the classical run time Tc of state vector simulation, as a function of the active volume V , for the above circuit family: Tc ∼V 2(4vV/cd)cd. (20) We use Eq. (20) with the conservative values d = 2 and v = 0.1 to obtain the dashed ‘HPC’ line in Fig. 2. Since the classical run time is very sensitive to the velocity parameter v, we also include a colored background in Fig.",
        "metadata": {
            "author": "",
            "keywords": [
                "Substituting",
                "classical",
                "run",
                "time",
                "Fig.",
                "Fig",
                "simulation",
                "family",
                "state",
                "vector"
            ]
        }
    },
    {
        "id": "2fe37c1d-14b6-49ca-a591-22e8f3d28bff",
        "title": "",
        "chunk_text": "2, where the color scale corresponds to varying velocities v for fixed d = 2, showing how the graph Tc(V ) changes with different choices of the velocity v. In the darker areas in Fig. 2, finite QA is less fine tuned, as it holds for broader circuit families of a given volume (namely, also for lower velocities). Remark 8 (Circuit geometry and finite QA with EM) The above discussion provides insights regarding the choice of circuit geometry where it is best to look for early finite QAs with EM.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "finite",
                "showing",
                "velocities",
                "color",
                "scale",
                "corresponds",
                "varying",
                "fixed",
                "graph"
            ]
        }
    },
    {
        "id": "e575161c-f2fc-4337-b73e-29da15e54c72",
        "title": "",
        "chunk_text": "Equation (20) shows that Tc grows exponentially with V with an exponent that becomes ‘worse’ the larger v or d become. The dimension d is essentially unlimited in QPUs based on trapped ions and neutral atoms, but is restricted to ≤2 in current superconducting qubit QPUs. For fixed d, lower velocities correspond to more challenging circuits for EM relative to classical simulation.",
        "metadata": {
            "author": "",
            "keywords": [
                "Equation",
                "shows",
                "worse’",
                "grows",
                "exponentially",
                "exponent",
                "larger",
                "QPUs",
                "atoms",
                "lower"
            ]
        }
    },
    {
        "id": "d4cd5a9a-4a56-4846-8d17-1837c39aef38",
        "title": "",
        "chunk_text": "Thus, for early finite QA using EM, we may therefore 26For each 2-qubit gate, 2n−2 matrix-vector multiplications of complex dimension 4. Conversion between complex and real floating-point operations leads to an additional factor of 7.5 [95]. 27We ignore here memory requirements, which only increase the run time, and revisit these in Sec. 5.2.3. 21 5 USEFUL FINITE QAS EXPECTED IN THE NEAR FUTURE USING EM seek circuits with high velocity. Intuitively, we can understand this directly from Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "gate",
                "matrix-vector",
                "dimension",
                "finite",
                "complex",
                "early",
                "multiplications",
                "Sec",
                "Intuitively",
                "Conversion"
            ]
        }
    },
    {
        "id": "a122150d-03de-45ea-819b-36269132bad5",
        "title": "",
        "chunk_text": "(19), in which Tc grows exponentially with n and only linearly with V . It follows that, for fixed volume, ‘balanced’ circuits, where D ∼n1/d, and so n ∼V cd, are harder to classically simulate than circuits that are narrow and deep (D ≫n1/d, or n ≪V cd), and therefore balanced circuits are more suited for early demonstrations of finite QA.28 We expect such geometrical considerations to play an important role in near term demonstrations of finite QA with EM.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuits",
                "demonstrations",
                "finite",
                "volume",
                "balanced’",
                "deep",
                "grows",
                "exponentially",
                "linearly",
                "fixed"
            ]
        }
    },
    {
        "id": "5a035a16-006e-452e-974f-e417cc4eca8a",
        "title": "",
        "chunk_text": "5.2.3 Comparison to classical HPC (2): Tensor network contraction So far, we explicitly considered the run time of state-vector simulation, ignoring memory requirements and additional simulation methods. In practice, state-vector simulation is limited by memory requirements to under 50 qubits, and the current leading method for simulating generic quantum circuits seems to be tensor network contraction [98–100].",
        "metadata": {
            "author": "",
            "keywords": [
                "Comparison",
                "HPC",
                "Tensor",
                "network",
                "simulation",
                "ignoring",
                "contraction",
                "state-vector",
                "memory",
                "requirements"
            ]
        }
    },
    {
        "id": "c75f725b-22ce-4f12-a09a-e7bd9647f525",
        "title": "",
        "chunk_text": "The method is based on the representation of a given quantum circuit as a single tensor network (TN), which is contracted via an optimized ordering of tensors [101, 102]. Apart from potentially reducing memory requirements relative to state-vector simulation (at least for circuits with uniform connectivity, e.g., a d-dimensional lattice) [99], TN contraction can significantly reduce the run time, if the circuit has a ‘tree-width’ which is significantly smaller than the number of qubits [101].",
        "metadata": {
            "author": "",
            "keywords": [
                "network",
                "circuit",
                "method",
                "based",
                "representation",
                "quantum",
                "single",
                "contracted",
                "optimized",
                "ordering"
            ]
        }
    },
    {
        "id": "2e10dc12-193f-4227-8896-47472da646f3",
        "title": "",
        "chunk_text": "For circuits on a d-dimensional lattice of n qubits, this corresponds to the circuit depth D being smaller than the lattice diameter n1/d. However, for D > n1/d, the expression in Eq. (19) is a good estimate for the run time of TN contraction with state of the art classical algorithms and hardware (see e.g. Sec.IV.A in Ref. [98]). In our example D = (d/2v)n1/d (see Eq. (23) in Appendix A.3), so for d = 2, the above condition is met for velocities v which are not too close to 1.",
        "metadata": {
            "author": "",
            "keywords": [
                "lattice",
                "qubits",
                "diameter",
                "circuits",
                "circuit",
                "d-dimensional",
                "corresponds",
                "depth",
                "smaller",
                "Ref."
            ]
        }
    },
    {
        "id": "f7aee88d-7409-4da5-96ec-45bf59f67bc8",
        "title": "",
        "chunk_text": "The color scale in Fig. 2 emphasizes low velocities, for which TN contraction cannot significantly improve upon the run time of state-vector simulation. 5.2.4 Comparison to classical HPC (3): Additional simulation methods Though TN contraction is arguably the leading method for simulating generic quantum circuits [98–100], a convincing claim of finite QA would need to address additional classical simulation methods. Each known simulation method can evade the lower bound in Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "Fig.",
                "simulation",
                "contraction",
                "emphasizes",
                "velocities",
                "Additional",
                "Comparison",
                "HPC",
                "color",
                "scale"
            ]
        }
    },
    {
        "id": "5e7d2575-d958-423b-b802-6f441062b943",
        "title": "",
        "chunk_text": "(19) only for a very restricted family of circuits; and finite QA can only be achieved for circuit families that do not significantly overlap with any of these easy-to-simulate families. As a example, an important set of classical methods to consider is based on a TN representation of the initial state (TNS), and the evolution of this representation through the circuit. Such methods are advantageous for circuits that create limited entanglement (see e.g., Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "families",
                "TNS",
                "restricted",
                "family",
                "finite",
                "achieved",
                "significantly",
                "overlap",
                "circuits",
                "circuit"
            ]
        }
    },
    {
        "id": "529a0159-8623-4dc0-b7f7-7aadb6ca7b02",
        "title": "",
        "chunk_text": "[103]), so to ensure that they do not admit a run time significantly lower than Eq. (19), we must consider circuits in which all n qubits are sufficiently entangled. It is indeed expected that in generic cases the n active qubits in Eq. (19) are significantly entangled, in which case TNS methods would not be advantageous over state vector.29 We note that Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "entangled",
                "ensure",
                "admit",
                "run",
                "time",
                "lower",
                "significantly",
                "qubits",
                "Ref",
                "TNS"
            ]
        }
    },
    {
        "id": "4f8081e3-a8be-403b-a346-7de19a1d4062",
        "title": "",
        "chunk_text": "[105] constructed examples for high dimensional qudits where this is not the case, and the number of active qubits is much larger than the number of qubits which are significantly entangled. For such circuits, the classical run time of TNS methods might be significantly better than Eq. (19).",
        "metadata": {
            "author": "",
            "keywords": [
                "number",
                "qubits",
                "constructed",
                "case",
                "entangled",
                "significantly",
                "high",
                "dimensional",
                "qudits",
                "active"
            ]
        }
    },
    {
        "id": "e660af94-79a0-4350-b124-46520eedcdbd",
        "title": "",
        "chunk_text": "However, while the entanglement growth velocity is generally only upper bounded by the operator spreading velocity v [96, 105], we are not aware of examples where the two velocities differ significantly for generic, dense, quantum circuits, defined on qubits. 28To compensate for the ‘un-balanced’ shape of the active volume in circuits with low velocity v, we may choose to measure observables supported on more than a single qubit, essentially chopping the top of the pyramid-shaped active volume.",
        "metadata": {
            "author": "",
            "keywords": [
                "velocity",
                "dense",
                "generic",
                "quantum",
                "defined",
                "circuits",
                "entanglement",
                "growth",
                "generally",
                "upper"
            ]
        }
    },
    {
        "id": "de6522db-e24f-485d-a29c-91a8303908cd",
        "title": "",
        "chunk_text": "Such higher-weight observables will not, however, be advantageous for circuits with high velocity, where they lead to an imbalance in the opposite direction, D < n1/d. As explained below, such circuits admit a reduced classical run time relative to Eq. (19), via tensor-network contraction algorithms. 29As an interesting recent example, the TNS approach of [104] proved useful for simulating the naively large volume experiment of [48].",
        "metadata": {
            "author": "",
            "keywords": [
                "velocity",
                "direction",
                "circuits",
                "higher-weight",
                "observables",
                "advantageous",
                "high",
                "lead",
                "imbalance",
                "opposite"
            ]
        }
    },
    {
        "id": "0bfe79e3-1357-49a7-a378-c47ffc0e7720",
        "title": "",
        "chunk_text": "However, as shown in [98], the number of active qubits was significantly smaller than the total number of qubits in the circuit, such that efficient state-vector simulations were also possible. 22 6 EM IN THE ERA OF FAULT TOLERANT EC Two additional notable examples which would require significantly less run time for classical simulation than Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "number",
                "qubits",
                "circuit",
                "significantly",
                "shown",
                "active",
                "smaller",
                "total",
                "efficient",
                "state-vector"
            ]
        }
    },
    {
        "id": "fc339a42-927c-48f5-ba69-291cede933dd",
        "title": "",
        "chunk_text": "(19), include circuits with mostly Clifford gates, which can be simulated efficiently based on the stabilizer formalism [106]; as well as circuits with mostly ‘matchgates’, which can be simulated efficiently based on a mapping of qubits to free fermions [107]. The above easy-to-simulate circuit families and corresponding simulation algorithms were discovered as part of extensive (and ongoing) research effort in quantum computational complexity.",
        "metadata": {
            "author": "",
            "keywords": [
                "simulated",
                "efficiently",
                "based",
                "matchgates’",
                "Clifford",
                "include",
                "gates",
                "formalism",
                "fermions",
                "circuits"
            ]
        }
    },
    {
        "id": "64327bd9-64a6-4975-8a3b-e2ae2951456a",
        "title": "",
        "chunk_text": "It is possible that additional studies will identify additional restricted circuit families that may be simulated efficiently. Nevertheless, we take Eq. (19) as an estimate for the run time of state-of-the-art classical simulation of generic quantum circuits actively involving n qubits and V gates; and with the connectivity of a d- dimensional lattice and circuit depth D > n1/d. This may be viewed as a finite-size complexity assumption, on which claims of finite QA may be based.",
        "metadata": {
            "author": "",
            "keywords": [
                "additional",
                "efficiently",
                "studies",
                "identify",
                "restricted",
                "families",
                "simulated",
                "circuit",
                "classical",
                "gates"
            ]
        }
    },
    {
        "id": "6134fcf0-f7c0-4ae4-bc85-10db3ba064b0",
        "title": "",
        "chunk_text": "As a final remark, we note that the run time for EM scales as ϵ−2 (as in Eq. (3)) with the allowed inaccuracy ϵ, while the expression (19) for the classical run time is naively independent of ϵ. As a result, finite QA with EM seems to be easier for larger ϵ, and more challenging with small ϵ. Of course, one may ask whether classical simulation methods can utilize the allowed inaccuracy to save in run time. First, note that since Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "run",
                "time",
                "remark",
                "allowed",
                "final",
                "scales",
                "note",
                "inaccuracy",
                "classical",
                "expression"
            ]
        }
    },
    {
        "id": "e84f3d6c-7404-4377-a244-5334971c9bce",
        "title": "",
        "chunk_text": "(19) involves the active volume and active qubit number, the run time is already reduced based on the allowed inaccuracy ϵ. Beyond this, despite results showing significant reductions in the run time for noisy circuit simulation based on its large deviation from the ideal circuit [61, 108], we are not aware of significant reductions in the run time of ideal circuit simulation given a small allowed inaccuracy ϵ ≪1.",
        "metadata": {
            "author": "",
            "keywords": [
                "run",
                "time",
                "active",
                "inaccuracy",
                "circuit",
                "based",
                "allowed",
                "involves",
                "number",
                "reductions"
            ]
        }
    },
    {
        "id": "e5395053-0e89-45c8-bd03-bd579a5825fd",
        "title": "",
        "chunk_text": "6 EM in the era of fault tolerant EC 6.1 The fault tolerance misconception: Why additional error reduction is needed even when fault tolerant EC is available A common misconception in the quantum ecosystem is that fault tolerant EC is thought to handle errors in the best and most efficient way, and therefore, once EC abilities become available to end-users, no other error reduction methods will be needed.",
        "metadata": {
            "author": "",
            "keywords": [
                "tolerant",
                "fault",
                "reduction",
                "misconception",
                "needed",
                "error",
                "end-users",
                "era",
                "tolerance",
                "additional"
            ]
        }
    },
    {
        "id": "9441ba26-2c54-4feb-af22-12a19f96744e",
        "title": "",
        "chunk_text": "The origin of this misconception comes from the fact that the original fault tolerance results [11–14] assumed that the model of quantum computation can be described by the set of gates available, accompanied by a single parameter γ indicating the fidelity of the individual qubits or gates in the system.",
        "metadata": {
            "author": "",
            "keywords": [
                "gates",
                "results",
                "assumed",
                "accompanied",
                "system",
                "origin",
                "misconception",
                "fact",
                "original",
                "fault"
            ]
        }
    },
    {
        "id": "50bafe94-e72f-4d49-a314-072d7bd88709",
        "title": "",
        "chunk_text": "The assumption in all those results is that once the desired below-threshold infidelity γ is achieved for single gates, an unbounded number of qubits with this fixed error rate is available upon demand. This picture is also in line with the usual picture of condensed matter physics, in which the local properties of the physical system are fixed and then one takes the size of the system to infinity to arrive at the thermodynamic limit.",
        "metadata": {
            "author": "",
            "keywords": [
                "fixed",
                "gates",
                "demand",
                "assumption",
                "results",
                "desired",
                "below-threshold",
                "infidelity",
                "achieved",
                "single"
            ]
        }
    },
    {
        "id": "3d744208-ca11-4441-8455-620137bcc82a",
        "title": "",
        "chunk_text": "This idealistic picture, however, is not how things work in the reality of quantum computer implementations. Over the past decade, qubit numbers in existing QPUs have been increasing steadily but slowly.",
        "metadata": {
            "author": "",
            "keywords": [
                "picture",
                "implementations",
                "idealistic",
                "things",
                "work",
                "reality",
                "quantum",
                "computer",
                "decade",
                "qubit"
            ]
        }
    },
    {
        "id": "33b62742-5689-4b9d-b548-3f9180596ea9",
        "title": "",
        "chunk_text": "This had been the case in all leading hardware platforms, in particular those based on superconducting qubits and trapped ions, and it is expected to continue to be the situation in the foreseeable future, according to the road maps of all major quantum computing manufacturers, see e.g., [16, 18]. The qubit numbers predicted for neutral atom based quantum processors are larger, but nevertheless restricted, see e.g., [17].",
        "metadata": {
            "author": "",
            "keywords": [
                "platforms",
                "ions",
                "future",
                "manufacturers",
                "based",
                "quantum",
                "case",
                "leading",
                "hardware",
                "superconducting"
            ]
        }
    },
    {
        "id": "6a9e343e-8a36-4f87-b276-ddf196dff1a6",
        "title": "",
        "chunk_text": "The situation is somewhat different in photon based QPUs, which we exclude from this discussion. We therefore consider here hardware platforms in which the increase in the number of high quality qubits is gradual; at any point in time in the foreseeable future, the number of qubits is upper bounded and limited by some fixed number, and the end-users at that point in time can only make use of QPUs of that size. This limit on the number of qubits has severe consequences.",
        "metadata": {
            "author": "",
            "keywords": [
                "number",
                "qubits",
                "QPUs",
                "discussion",
                "situation",
                "photon",
                "based",
                "exclude",
                "point",
                "time"
            ]
        }
    },
    {
        "id": "715841b2-b6b8-4039-9316-575b7d4d67ca",
        "title": "",
        "chunk_text": "When the number of high quality qubits is limited, the user must choose between spending the qubits on EC, or on logical qubits for computation (namely, the number of qubits in the ideal circuit). Thus there is a trade-off between the number of logical qubits, and their quality, namely, the logical error. Say, for example, that we are looking a few years ahead into the future, when QPUs consisting of 104 high quality 23 6 EM IN THE ERA OF FAULT TOLERANT EC (below threshold) qubits are available.",
        "metadata": {
            "author": "",
            "keywords": [
                "number",
                "qubits",
                "logical",
                "quality",
                "limited",
                "computation",
                "circuit",
                "high",
                "user",
                "choose"
            ]
        }
    },
    {
        "id": "39af3121-6d9d-4812-949a-69858a6e9246",
        "title": "",
        "chunk_text": "Suppose then that we want to run a quantum circuit on 103 logical qubits; in this case we can only use EC with a rate of 1/10 logical qubits to physical qubits. Such an EC code can only reduce the logical error rate by a limited amount; denote the resulting logical error by γ′. Using Eq. (12), this directly translates to an upper bound on the volume of the logical quantum circuit that can be run, V ∼ϵ/γ′, for a required accuracy ϵ.",
        "metadata": {
            "author": "",
            "keywords": [
                "qubits",
                "logical",
                "Suppose",
                "rate",
                "case",
                "physical",
                "error",
                "quantum",
                "circuit",
                "run"
            ]
        }
    },
    {
        "id": "ac04c066-569b-4763-b859-864d425901a3",
        "title": "",
        "chunk_text": "Perhaps the user would resort to running a circuit of just 100 logical qubits? That would leave her the possibility of using an EC scheme with rate 1/100, which if chosen correctly, can reduce the logical error by many orders of magnitudes compared to the physical one, and allow her to run very deep quantum circuits on those 100 qubits.",
        "metadata": {
            "author": "",
            "keywords": [
                "qubits",
                "logical",
                "user",
                "resort",
                "running",
                "circuit",
                "circuits",
                "rate",
                "correctly",
                "leave"
            ]
        }
    },
    {
        "id": "cf97bfaa-255e-4925-96d5-555ecae64a8f",
        "title": "",
        "chunk_text": "We note that the effectiveness of EC protocols (namely, the value of the logical error rate γ′ that is achieved) depends very strongly (in fact, exponentially) on the distance of the EC code used.",
        "metadata": {
            "author": "",
            "keywords": [
                "exponentially",
                "protocols",
                "achieved",
                "depends",
                "strongly",
                "fact",
                "note",
                "effectiveness",
                "logical",
                "error"
            ]
        }
    },
    {
        "id": "b54d9e5c-5c58-4f4f-8d8e-acfb67c0772d",
        "title": "",
        "chunk_text": "However, increasing the code distance usually comes at the expense of reducing the code rate, entailing an increase in the required number of physical qubits.30 This means that reducing the number of logical qubits in the above example from 103 to a 100, namely by a factor of ten, leads to a dramatic improvement in the logical error rate, which in turn allows an increase by a factor much larger than 10 in the volume.",
        "metadata": {
            "author": "",
            "keywords": [
                "rate",
                "code",
                "reducing",
                "increase",
                "number",
                "factor",
                "logical",
                "increasing",
                "entailing",
                "physical"
            ]
        }
    },
    {
        "id": "0ecb2628-ce50-4f68-b0f5-aa1d4602f5a1",
        "title": "",
        "chunk_text": "We see that there is an important trade off: if we want to reduce the logical error rate significantly (in order to run logical circuits with larger volume), we will need to invest a lot of our qubit resources in EC, which will limit the logical circuits we can run to much fewer logical qubits.",
        "metadata": {
            "author": "",
            "keywords": [
                "logical",
                "circuits",
                "run",
                "significantly",
                "volume",
                "important",
                "trade",
                "reduce",
                "error",
                "rate"
            ]
        }
    },
    {
        "id": "5b0134a9-be81-44b1-8c0e-5527ea3ddbe9",
        "title": "",
        "chunk_text": "The upshot is that in the foreseeable future, and for as long as the number of high quality qubits is limited, circuit volumes and logical qubit numbers will be limited due to noise, even in the era of fault tolerant EC. Hence, while volumes available by EM are severely limited due to limitations on available QPU time (cf. Sec. 4), the volumes possible with fault tolerant EC are also limited – due to restricted qubit numbers.",
        "metadata": {
            "author": "",
            "keywords": [
                "due",
                "limited",
                "volumes",
                "tolerant",
                "future",
                "circuit",
                "noise",
                "fault",
                "Sec",
                "upshot"
            ]
        }
    },
    {
        "id": "2baf29aa-0f55-4f28-9712-6af6e64e621c",
        "title": "",
        "chunk_text": "Here is an example demonstrating the circuit volumes expected to be available when just using EC in the near future, say with an optimistic fidelity γ = 5 × 10−4. In this case, the bare volume available for required accuracy ϵ = 1% is Vbare ∼ϵ/γ = 20 gates (following the rule of thumb of Eq. (13)). How much can we improve on this when using EC? This, as explained above, depends on how much of our qubit resource we want to spend on EC.",
        "metadata": {
            "author": "",
            "keywords": [
                "future",
                "demonstrating",
                "circuit",
                "expected",
                "optimistic",
                "fidelity",
                "Vbare",
                "gates",
                "volumes",
                "volume"
            ]
        }
    },
    {
        "id": "2dbc2ec0-e501-41d3-8c20-30bb8b63b29b",
        "title": "",
        "chunk_text": "Suppose we have 103 physical qubits at hand, with this fidelity. If we want to run a circuit on 100 logical qubits, we can only afford using an EC code of rate roughly 1/10; we could use Steane’s code. We note that as in the bare case, we can estimate the available logical volume by the same rule of thumb, VEC ∼ϵ/γ′, (21) where the physical infidelity γ is replaced by the logical infidelity γ′.",
        "metadata": {
            "author": "",
            "keywords": [
                "Suppose",
                "hand",
                "fidelity",
                "qubits",
                "logical",
                "physical",
                "code",
                "VEC",
                "Steane",
                "infidelity"
            ]
        }
    },
    {
        "id": "6dab342c-92b1-49fb-92d4-b02e0f8de5c4",
        "title": "",
        "chunk_text": "We see that EC only increases the available volume compared to the bare case, by the same factor by which Steane’s code improves the logical error rate compared to the physical error rate. With a fidelity of 5 × 10−4 and taking into account that the threshold for Steane’s code with state-of-the-art fault-tolerant constructions is ∼10−3, we get that the increase in volume would be less than a factor 2 (see Fig. 3, blue line).",
        "metadata": {
            "author": "",
            "keywords": [
                "compared",
                "error",
                "rate",
                "Steane",
                "code",
                "volume",
                "factor",
                "case",
                "bare",
                "improves"
            ]
        }
    },
    {
        "id": "0f2c697f-2b6b-46ea-a792-490c18c2d199",
        "title": "",
        "chunk_text": "This enables reaching logical circuit volumes < 40, certainly not sufficient for achieving finite QA. Luckily, this situation can be remedied. While noise limits the circuit volumes that can be executed even when fault tolerant EC is used, the volume available can be significantly increased, in fact by several orders of magnitude, by using EM in conjunction with EC. We explain this combination now.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "enables",
                "reaching",
                "logical",
                "sufficient",
                "achieving",
                "finite",
                "volumes",
                "Luckily",
                "remedied"
            ]
        }
    },
    {
        "id": "4dcc2894-2c12-4bf1-967a-49b83a613047",
        "title": "",
        "chunk_text": "6.2 Logical EM: Combining EM with EC to provide further circuit volume boosts To address the challenges of EC and EM, and go beyond their respective limitations, the combination of the two methods was recently proposed [109–113], and very recently demonstrated [114]. We refer to this general approach as logical error mitigation (LEM).",
        "metadata": {
            "author": "",
            "keywords": [
                "Combining",
                "recently",
                "limitations",
                "proposed",
                "demonstrated",
                "Logical",
                "LEM",
                "provide",
                "circuit",
                "volume"
            ]
        }
    },
    {
        "id": "ff5ffd71-7d6d-4e05-85da-b3c7b2acdcd4",
        "title": "",
        "chunk_text": "In terms of quantum resources, LEM enables to optimize the use of both available QPU time and physical qubit numbers, to maximize accessible circuit volume and output accuracy, with the given resources. 30The inverse relation between code distance and code rate holds in commonly used code families, such as Surface codes or code concatenations.",
        "metadata": {
            "author": "",
            "keywords": [
                "resources",
                "LEM",
                "QPU",
                "numbers",
                "accuracy",
                "code",
                "terms",
                "quantum",
                "enables",
                "optimize"
            ]
        }
    },
    {
        "id": "4352a8fe-fda3-423a-bb4d-e56a57547526",
        "title": "",
        "chunk_text": "An exception occurs in qLDPC codes of constant rate – codes in which the rate is bounded from below by a constant > 0 independent of the code length that may grow unboundedly. However even for such codes, increasing the code distance means investing more physical qubits; see Tab. 2 and surrounding text regarding the LP qLDPC codes.",
        "metadata": {
            "author": "",
            "keywords": [
                "constant",
                "rate",
                "codes",
                "independent",
                "unboundedly",
                "qLDPC",
                "exception",
                "occurs",
                "bounded",
                "length"
            ]
        }
    },
    {
        "id": "69b4b115-fcb1-4ba4-8e96-b2cbd4574b3e",
        "title": "",
        "chunk_text": "24 6 EM IN THE ERA OF FAULT TOLERANT EC 6.2.1 External LEM The LEM methods described in the literature may be roughly summarized as follows: apply EC to generate logical operations with a reduced error rate relative to physical operations; then apply EM to these logical operations, as if they are physical operations. One can view this is as follows.",
        "metadata": {
            "author": "",
            "keywords": [
                "LEM",
                "operations",
                "External",
                "ERA",
                "FAULT",
                "TOLERANT",
                "logical",
                "physical",
                "apply",
                "methods"
            ]
        }
    },
    {
        "id": "92bf78e4-d9d3-4973-8c29-05a5be157a2c",
        "title": "",
        "chunk_text": "To create LEM, we start with some EM protocol, and replace each gate used by it by an error-corrected logical gate, including syndrome measurements, decoding and recovery operations. This results in the LEM protocol in which EM acts on the logical qubits.",
        "metadata": {
            "author": "",
            "keywords": [
                "LEM",
                "including",
                "measurements",
                "decoding",
                "operations",
                "gate",
                "protocol",
                "logical",
                "create",
                "start"
            ]
        }
    },
    {
        "id": "d1a315e4-6988-4116-a9ce-1ca40c2eb4d4",
        "title": "",
        "chunk_text": "We refer to this approach as ‘external LEM’ (ExtLEM), since it does not make use of the wealth of internal syndrome data generated by logical operations.31 Assuming that ExtLEM is based on an EM protocol which is either unbiased, or produces a bias which is negligible relative to the required accuracy ϵ, we immediately obtain from Sec. 5.1 the order of magnitude estimate VLEM ∼1–10 γ′ (22) for the logical circuit volume available with LEM.",
        "metadata": {
            "author": "",
            "keywords": [
                "Assuming",
                "Sec",
                "ExtLEM",
                "external",
                "LEM’",
                "unbiased",
                "logical",
                "refer",
                "approach",
                "make"
            ]
        }
    },
    {
        "id": "1a506fe2-db9e-435a-806a-13b443fce8d8",
        "title": "",
        "chunk_text": "Accordingly, the circuit volume boosts (CVBs) of ∼1–10/ϵ shown in Fig. 1 for EM over bare circuit execution, are maintained when comparing ExtLEM to EC. Thus, LEM enables ∼1–10/ϵ larger logical circuit volumes compared to those provides by EC alone, on the same hardware and with the same output accuracy, see blue and green curves in Fig. 3.",
        "metadata": {
            "author": "",
            "keywords": [
                "Fig.",
                "CVBs",
                "circuit",
                "boosts",
                "execution",
                "shown",
                "bare",
                "maintained",
                "comparing",
                "ExtLEM"
            ]
        }
    },
    {
        "id": "8cac0f30-1ffc-4b37-8122-807d992ad2c2",
        "title": "",
        "chunk_text": "75 80 85 90 95 100 100 101 102 103 1-ϵ [%] CVB=V/Vbare bare EC EM ExtLEM EC+PS SALEM Figure 3: An example for circuit volume boosts (CVBs) with different error reduction strategies, with and without EC. The different curves indicate the CVBs relative to bare circuit execution, due to EC, EM, an ‘external’ mitigation of logical errors (ExtLEM), the combination of EC and post-selection (EC+PS), and a syndrome-aware mitigation of logical errors (SALEM) [115].",
        "metadata": {
            "author": "",
            "keywords": [
                "Vbare",
                "Figure",
                "SALEM",
                "CVBs",
                "boosts",
                "strategies",
                "errors",
                "bare",
                "ExtLEM",
                "circuit"
            ]
        }
    },
    {
        "id": "eca72b79-5d8e-43b8-be04-13858896473b",
        "title": "",
        "chunk_text": "All methods are given a very mild allowed shot overhead R = 2. The data presented was obtained from numerical simulations of repeated EC cycles (a logical memory circuit), with the well-known Steane code (7-qubit color code), based on the fault-tolerant construction of Ref. [116]. The results hold qualitatively for any EC code, but will be quantitatively different, e.g. the blue line will be higher with better EC schemes (cf. Tab. 2). For ease of reference, focus on 95% output accuracy.",
        "metadata": {
            "author": "",
            "keywords": [
                "code",
                "methods",
                "mild",
                "allowed",
                "shot",
                "overhead",
                "Ref",
                "Steane",
                "Tab.",
                "cycles"
            ]
        }
    },
    {
        "id": "5977fa33-5d10-4c9d-aa65-a103d25b4a6d",
        "title": "",
        "chunk_text": "We compare the volume boosts for different methods. For an infidelity of 5 × 10−4, slightly below the Steane code’s threshold, logical errors are slightly smaller than physical errors, and EC provides a small CVB (blue) compared to bare execution. This CVB does not improve with required accuracy, because EC suffers a significant bias due to logical errors (similarly to the bias in the bare computation, discussed in Sec. 5.1).",
        "metadata": {
            "author": "",
            "keywords": [
                "methods",
                "CVB",
                "errors",
                "compare",
                "volume",
                "boosts",
                "logical",
                "Steane",
                "slightly",
                "bare"
            ]
        }
    },
    {
        "id": "bc62a837-9a9c-4045-aad5-f3422ef207b6",
        "title": "",
        "chunk_text": "Unbiased EM (yellow), applied directly to physical qubits, is better than EC for the Steane code and chosen infidelity of 5 × 10−4. ExtLEM (green), where EM is naively applied to logical gates, enjoys the benefits of both EC and EM, and provides a larger CVB than EM. The remaining methods, EC+PS and SALEM, are discussed in the main text.",
        "metadata": {
            "author": "",
            "keywords": [
                "Steane",
                "yellow",
                "Unbiased",
                "qubits",
                "applied",
                "directly",
                "physical",
                "code",
                "chosen",
                "infidelity"
            ]
        }
    },
    {
        "id": "6915a6ab-37e4-4ec6-a8a1-262fb0464aa0",
        "title": "",
        "chunk_text": "31We note that existing work does make use of several features of logical operations which are not present in physical operations, such as the ability to virtually apply Pauli operations by keeping track of a ‘Pauli frame’ [109], as well as the expected lower logical error of Clifford gates relative to non-Clifford gates [110, 111, 113].",
        "metadata": {
            "author": "",
            "keywords": [
                "Pauli",
                "operations",
                "Clifford",
                "logical",
                "gates",
                "note",
                "frame’",
                "existing",
                "work",
                "make"
            ]
        }
    },
    {
        "id": "1beaa707-b69a-4e87-b142-822834226dd9",
        "title": "",
        "chunk_text": "25 6 EM IN THE ERA OF FAULT TOLERANT EC 6.2.2 Error correction combined with post-selection An alternative strategy to mitigate logical errors, which is routinely used in EC experiments, is based on post-selection (PS) [117, 118]. Here, one employs decoders that reject certain syndromes, discarding the circuit repetitions (shots) in which they are observed.",
        "metadata": {
            "author": "",
            "keywords": [
                "ERA",
                "FAULT",
                "TOLERANT",
                "post-selection",
                "experiments",
                "Error",
                "errors",
                "correction",
                "combined",
                "alternative"
            ]
        }
    },
    {
        "id": "37b4da35-28a7-4eb7-b74a-6eabb5277407",
        "title": "",
        "chunk_text": "We refer to this strategy as EC+PS, to highlight the fact that the accepted set of syndromes is not only kept but also decoded and recovered from, as in standard EC.32 Let us compare ExtLEM to the approach of EC+PS. In the latter method, one rejects a set of syndromes, which means that errors associated with these syndrome will not contribute to the output distribution, which is computed by conditioning on accepted (and corrected) syndromes only.",
        "metadata": {
            "author": "",
            "keywords": [
                "syndromes",
                "set",
                "standard",
                "accepted",
                "refer",
                "strategy",
                "highlight",
                "fact",
                "decoded",
                "recovered"
            ]
        }
    },
    {
        "id": "466eaf37-d7b8-471a-a3b0-82db7e8d5728",
        "title": "",
        "chunk_text": "Thus, in EC+PS only the logical errors in rejected syndromes are mitigated (by rejection of the corresponding shots), while leaving the logical errors in accepted syndromes intact. This generically leads to a significant bias b. On the other hand, if the rejected set of syndromes is chosen appropriately, the above ‘rejected’ logical errors are mitigated (by shot rejection) very efficiently, in the sense of a blowup rate λ that can be as low as 1 (cf. toy example in Sec. 4).",
        "metadata": {
            "author": "",
            "keywords": [
                "logical",
                "errors",
                "mitigated",
                "syndromes",
                "intact",
                "leaving",
                "accepted",
                "rejected",
                "rejection",
                "Sec."
            ]
        }
    },
    {
        "id": "d28acded-82b8-47e0-8217-4d187337105e",
        "title": "",
        "chunk_text": "These features determine the behavior of the CVB due to EC+PS, which is generically better than that of ExtLEM when b ≪ϵ, but significantly under-performs when b ≫ϵ, see e.g., purple curve in Fig. 3. 6.2.3 Syndrome Aware Logical EM (SALEM) In fact, it turns out that both ExtLEM and EC+PS may be viewed as instances of a more general framework, that extends and improves upon both. We refer to this framework as syndrome-aware LEM (SALEM), and provide its detailed technical description in Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "SALEM",
                "Fig.",
                "Syndrome",
                "CVB",
                "Aware",
                "Logical",
                "ExtLEM",
                "purple",
                "fact",
                "framework"
            ]
        }
    },
    {
        "id": "76c5f55a-ab46-4503-9f5b-ceac3a4615cc",
        "title": "",
        "chunk_text": "[115]. In essence, SALEM allows to maintain the negligible bias possible with ExtLEM, while significantly improving upon its blowup rate. Figure 3 (red curve) demonstrates these performance improvements of SALEM relative to ExtLEM and EC+PS. 6.2.4 Logical EM with state of the art EC codes Our discussion of LEM so far used the prototypical Steane code as an example.",
        "metadata": {
            "author": "",
            "keywords": [
                "SALEM",
                "ExtLEM",
                "Logical",
                "Figure",
                "essence",
                "rate",
                "LEM",
                "Steane",
                "red",
                "curve"
            ]
        }
    },
    {
        "id": "67ab0ff2-068f-4fde-b650-a11f4929707a",
        "title": "",
        "chunk_text": "And while the simplicity and high rate of the Steane code made it a useful example for recent EC experiments, its low threshold value ∼10−3 makes it impractical for useful EC in the near term. This is reflected by the small CVB of EC relative to bare execution, even with an optimistic infidelity of 5×10−4 (blue curve in Fig. 3). We now provide examples for the benefits of LEM over mere EC.",
        "metadata": {
            "author": "",
            "keywords": [
                "Steane",
                "experiments",
                "makes",
                "term",
                "simplicity",
                "high",
                "rate",
                "code",
                "made",
                "recent"
            ]
        }
    },
    {
        "id": "59a80d16-321b-4892-8a9a-1ceededaab80",
        "title": "",
        "chunk_text": "We consider three state of the art code families: Surface codes, BB qLDPC codes, and LP qLDPC codes [23, 24]. These are examples of codes expected to lead to significant performance improvements over bare circuit execution by the end of the decade, at least according to current hardware road maps [15–18]. In our analysis, we set aside the details of how LEM is performed, and use only the order of magnitude estimates in Eq. (21) and (22). This is summarized in Tab. 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "Surface",
                "qLDPC",
                "codes",
                "families",
                "state",
                "art",
                "LEM",
                "Tab",
                "code",
                "decade"
            ]
        }
    },
    {
        "id": "6e0ba64a-e180-4ed8-8325-13243451ec26",
        "title": "",
        "chunk_text": "Within each of the three code families, we consider two codes, the second one having a lower logical error than the former. For the Surface and BB qLDPC code families, the improvement in logical error rate comes at the cost of reducing the rate of the code, thus requiring more physical qubits for a fixed number of logical qubits.",
        "metadata": {
            "author": "",
            "keywords": [
                "families",
                "code",
                "logical",
                "error",
                "lower",
                "rate",
                "qubits",
                "Surface",
                "codes",
                "qLDPC"
            ]
        }
    },
    {
        "id": "d4a1be7e-7a95-4219-9d0d-7a6d5653c97e",
        "title": "",
        "chunk_text": "The case of the LP qLDPC family is different, since the distance of these codes can increase unboundedly (leading to an exponential decrease in the logical error rate per qubit) while keeping the rate of the code above a fixed constant > 0. However, this requires working with codes in the family with whose block size (ntot in Tab. 1) also grows unboundedly, eventually surpassing the total number of physical qubits in a given QPU.",
        "metadata": {
            "author": "",
            "keywords": [
                "rate",
                "family",
                "unboundedly",
                "codes",
                "leading",
                "constant",
                "case",
                "qLDPC",
                "distance",
                "increase"
            ]
        }
    },
    {
        "id": "7d983f53-e6b4-42ae-b777-89eb77dc6612",
        "title": "",
        "chunk_text": "Thus, again, an increase in the number of physical qubits is generally required in order to reduce the logical error rate. In the examples given in Tab.",
        "metadata": {
            "author": "",
            "keywords": [
                "rate",
                "increase",
                "number",
                "physical",
                "qubits",
                "generally",
                "required",
                "order",
                "reduce",
                "logical"
            ]
        }
    },
    {
        "id": "4067e893-ceb0-4f65-b21a-299e7644fab8",
        "title": "",
        "chunk_text": "2, the improvement in logical error rate from the first LP qLDPC code to the second, is in fact accompanied by a slightly higher rate, but comes at the price of a 1300-qubit increase in ntot – possibly requiring more physical qubits than 32We view PS without EC, that is, without decoding and recovering from accepted syndromes, as an EM method, as opposed to a LEM method. Note that PS can be performed even without EC codes, based on known symmetries of the ideal circuit [41].",
        "metadata": {
            "author": "",
            "keywords": [
                "method",
                "LEM",
                "rate",
                "increase",
                "ntot",
                "possibly",
                "view",
                "syndromes",
                "improvement",
                "logical"
            ]
        }
    },
    {
        "id": "71e8779f-aae6-4021-bc69-f6385e016a1d",
        "title": "",
        "chunk_text": "26 7 SUMMARY AND FORECAST: QA TIMELINE available on a near term QPU. The upshot is that in all three examples of code families, moving from the first code to the second code to improve the logical error rate requires increasing the required number of physical qubits for implementation. Assuming ϵ = 0.1, for each code family in Tab. 2, LEM of the first code enables to at least reproduce the available volumes of the second code, thus trading run time for physical qubits.",
        "metadata": {
            "author": "",
            "keywords": [
                "SUMMARY",
                "FORECAST",
                "QPU",
                "code",
                "TIMELINE",
                "term",
                "physical",
                "qubits",
                "Tab",
                "LEM"
            ]
        }
    },
    {
        "id": "9978c0de-ea70-4492-ba1b-379bccaf5621",
        "title": "",
        "chunk_text": "For estimation error ϵ = 0.01, LEM of the first code provides a significant improvement over the second code (without LEM). In particular, without LEM, and for ϵ = 0.01, none of the listed codes can reach volumes ∼106, the so-called MegaQuOp milestone [57], where one may expect quantum applications with industrial value (see e.g., Ref. [119] for proposed quantum simulation algorithms of industrially-relevant materials at or below these circuit volumes).",
        "metadata": {
            "author": "",
            "keywords": [
                "LEM",
                "Ref",
                "volumes",
                "code",
                "estimation",
                "error",
                "significant",
                "improvement",
                "quantum",
                "milestone"
            ]
        }
    },
    {
        "id": "8b6284da-87c5-4e91-819a-c8c1cb52a39d",
        "title": "",
        "chunk_text": "However, with LEM, the second code in each family reaches MegaQuOp with a small allowed shot overhead R (see Eq. (9)) while the first code can also reach MegaQuOp, given a more significant allowed shot overhead but with less physical qubits. Table 2: Examples of state of the art EC codes, and corresponding logical circuit volumes possible with EC alone, and with LEM.",
        "metadata": {
            "author": "",
            "keywords": [
                "LEM",
                "shot",
                "allowed",
                "overhead",
                "MegaQuOp",
                "family",
                "reaches",
                "small",
                "code",
                "qubits"
            ]
        }
    },
    {
        "id": "f5eb4d9f-9be5-4e0b-ba2a-f74b6428af60",
        "title": "",
        "chunk_text": "The total number of physical qubits ntot includes the both code qubits and ancilla qubits used for fault-tolerant syndrome measurements. The net rate is given by k/ntot. The logical error γ′ quoted here is defined per syndrome measurement cycle and per logical qubit, and at a physical infidelity γ = 10−3. Note that we consider here logical memory circuits, without any logical operations.",
        "metadata": {
            "author": "",
            "keywords": [
                "logical",
                "qubits",
                "ntot",
                "syndrome",
                "total",
                "number",
                "includes",
                "code",
                "ancilla",
                "fault-tolerant"
            ]
        }
    },
    {
        "id": "95fe2847-5636-41d8-bcb2-0dd4b4926e5b",
        "title": "",
        "chunk_text": "Current proposals for logical operations for qLDPC codes are based on teleportation to surface code patches, which degrades net rates [23, 24]. The columns VEC and VLEM represent the maximal logical circuit volumes possible with EC and LEM, based on the order of magnitude estimates (21) and (22), respectively. Code family Jn, k, dK ntot k/ntot γ′ VEC VLEM Surface, J81, 1, 9K 161 1/161 9 × 10−6 105ϵ 105 −106 Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "Current",
                "patches",
                "rates",
                "VEC",
                "VLEM",
                "based",
                "surface",
                "Ref",
                "logical",
                "LEM"
            ]
        }
    },
    {
        "id": "c28f5037-8795-49a8-9d6b-1540667f9881",
        "title": "",
        "chunk_text": "[24] J121, 1, 11K 241 1/241 9 × 10−7 106ϵ 106 −107 BB qLDPC, J72, 12, 6K 144 1/12 6 × 10−6 2 × 105ϵ 2 × (105 −106) Ref. [24] J144, 12, 12K 288 1/24 2 × 10−8 6 × 107ϵ 6 × (107 −108) LP qLDPC, J544, 80, ≤12K 1367 1/17 10−6 8 × 105ϵ 8 × (105 −106) Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ref",
                "qLDPC"
            ]
        }
    },
    {
        "id": "a39a99f0-ef52-47e0-9ce6-d09a91069235",
        "title": "",
        "chunk_text": "[23] J1428, 184, ≤24K 2670 1/15 10−7 9 × 106ϵ 9 × (106 −107) 6.3 Concluding remarks about logical EM To summarize, given a restricted number of physical qubits, LEM provides access to significantly larger logical circuit volumes relative to just EC, at the expense of a tolerable overhead in QPU time.",
        "metadata": {
            "author": "",
            "keywords": [
                "Concluding",
                "LEM",
                "QPU",
                "logical",
                "summarize",
                "qubits",
                "time",
                "remarks",
                "restricted",
                "number"
            ]
        }
    },
    {
        "id": "a22621a9-d0aa-4bb6-a6b5-fba53f4d7d7f",
        "title": "",
        "chunk_text": "And while adding more physical qubits to a given QPU is generally impossible for end users (and a formidable challenge for hardware manufacturers), allowing for more QPU time is always a possibility, which should be exploited based on its cost-effectiveness for the application at hand.",
        "metadata": {
            "author": "",
            "keywords": [
                "QPU",
                "users",
                "manufacturers",
                "allowing",
                "possibility",
                "hand",
                "adding",
                "physical",
                "qubits",
                "generally"
            ]
        }
    },
    {
        "id": "0477220a-7b26-4fbc-af65-f22e81354909",
        "title": "",
        "chunk_text": "The implication is that at any given moment in time, when EC becomes available, the combination of EM and EC, namely logical EM, will provide significantly larger circuit volumes than with EC alone, and thus should be viewed as the way to optimally use the available quantum resources. 7 Summary and forecast: QA timeline This paper refutes two common misconceptions ■Misconception 1: Error mitigation cannot provide any quantum advantage due to its exponentially scaling shot overhead.",
        "metadata": {
            "author": "",
            "keywords": [
                "time",
                "resources",
                "provide",
                "quantum",
                "implication",
                "moment",
                "combination",
                "logical",
                "significantly",
                "larger"
            ]
        }
    },
    {
        "id": "4eb1c0e3-a655-4db5-b55b-eb97e0bb6956",
        "title": "",
        "chunk_text": "We explained in this paper why this is a misconception. The origin of the misconception is a confusion between asymptotic QA and finite QA; we clarify the difference between these two notions in Sec. 2. 27 7 SUMMARY AND FORECAST: QA TIMELINE We then show that exponential asymptotic QA is indeed generically impossible using EM alone (Sec. 4) and at the same time, dramatic finite QAs are expected very soon using EM (Sec. 5.2).",
        "metadata": {
            "author": "",
            "keywords": [
                "Sec",
                "misconception",
                "explained",
                "paper",
                "asymptotic",
                "Sec.",
                "SUMMARY",
                "FORECAST",
                "finite",
                "TIMELINE"
            ]
        }
    },
    {
        "id": "aba05a74-2a4f-47e4-b612-08a0ae913e72",
        "title": "",
        "chunk_text": "■Misconception 2: Error mitigation will not be important once error correction becomes available. In Sec. 6 we explained why even when EC becomes available, this will not eliminate the problem of errors, as residual logical errors will still limit the volumes of quantum circuits that can be executed.",
        "metadata": {
            "author": "",
            "keywords": [
                "Misconception",
                "Sec",
                "mitigation",
                "important",
                "correction",
                "Error",
                "errors",
                "executed",
                "explained",
                "eliminate"
            ]
        }
    },
    {
        "id": "25a35e12-e5f4-400b-ae2f-7b1e974a8065",
        "title": "",
        "chunk_text": "We described how circuit volume boosts of a few orders of magnitude are expected using logical EM – the combination of EM and EC – compared to what can be achieved using EC alone on a given hardware platform.",
        "metadata": {
            "author": "",
            "keywords": [
                "compared",
                "platform",
                "circuit",
                "volume",
                "boosts",
                "orders",
                "magnitude",
                "expected",
                "logical",
                "combination"
            ]
        }
    },
    {
        "id": "b32ce139-85b0-49de-9ae3-d6643ea9c12e",
        "title": "",
        "chunk_text": "We conclude that the expected role to be played by EM on the road to the first finite QAs, and beyond, is crucial; EM is highly likely to be the first to provide the first useful finite QAs, and is expected to continue to have an important role also in the long run, when EC becomes a daily routine, by enabling significantly larger quantum circuits than what EC will enable on its own; thus enabling reaching a variety of finite QAs much earlier than would be possible with EC alone.",
        "metadata": {
            "author": "",
            "keywords": [
                "finite",
                "QAs",
                "expected",
                "role",
                "enabling",
                "crucial",
                "run",
                "routine",
                "conclude",
                "played"
            ]
        }
    },
    {
        "id": "adc923b9-8f47-441e-9d43-e4df035a4cda",
        "title": "",
        "chunk_text": "Based on the arguments presented here, Table 3 provides predictions regarding the expected advances along the finite QA timeline, with and without EM. In particular, it highlights two milestones that demonstrate the crucial role of EM on the road to QAs: 1. The first milestone is to experimentally demonstrate finite QA for the expectation value estimation problem. As argued in Sec. 5.2, and based on the hardware road maps cited in Tab.",
        "metadata": {
            "author": "",
            "keywords": [
                "Table",
                "timeline",
                "finite",
                "arguments",
                "presented",
                "predictions",
                "expected",
                "advances",
                "Based",
                "demonstrate"
            ]
        }
    },
    {
        "id": "9c6342aa-741f-480c-8567-99ccc2fbf4b7",
        "title": "",
        "chunk_text": "1, this is expected to be achieved in the very near future, by demonstrating the ability to execute generic quantum circuits of over 1000 two-qubit gates, using EM alone. This will constitute a demonstration of the first useful finite QAs. 2. The second milestone is to reach (logical) circuit volumes ∼105 −107, where the first industry- relevant applications are expected, using logical EM (LEM). As discussed in Sec.",
        "metadata": {
            "author": "",
            "keywords": [
                "future",
                "two-qubit",
                "gates",
                "achieved",
                "demonstrating",
                "ability",
                "execute",
                "generic",
                "quantum",
                "expected"
            ]
        }
    },
    {
        "id": "1cdc55ae-9a32-416e-81cc-925991dace65",
        "title": "",
        "chunk_text": "6.2.4, LEM significantly reduces the physical qubit numbers required for reaching these (logical) circuit volumes, relative to EC alone, thus expediting the corresponding finite QAs. Based on the hardware road maps cited in Tab. 1, we expect this milestone to be achieved within the next few years. Table 3: Conservative road map for finite QAs with EM and logical EM (LEM). In the LEM column we consider the state of the art qLDPC codes in Tab.",
        "metadata": {
            "author": "",
            "keywords": [
                "LEM",
                "Tab",
                "circuit",
                "volumes",
                "relative",
                "significantly",
                "reduces",
                "physical",
                "qubit",
                "numbers"
            ]
        }
    },
    {
        "id": "67c3aaf7-6921-4de7-ad49-1a38fce0fbc9",
        "title": "",
        "chunk_text": "2, but we allow for a larger net rate, up to 1/100, as may be needed for logical operations (beyond memory). For both EM and LEM we assume a mild allowed shot overhead, leading to a circuit volume boost ∼1/ϵ, as a function of the required output accuracy 1−ϵ. Note that while a 99.9% fidelity suffices for the third milestone with LEM, any improvement in fidelity translates to a significantly larger improvement in logical fidelity, enabling much larger volumes.",
        "metadata": {
            "author": "",
            "keywords": [
                "LEM",
                "larger",
                "rate",
                "operations",
                "memory",
                "net",
                "needed",
                "fidelity",
                "logical",
                "improvement"
            ]
        }
    },
    {
        "id": "e7bc023e-1efb-4c9f-8a59-7a4997a21f8b",
        "title": "",
        "chunk_text": "Milestone V ∼103 V ∼104 V ∼105 −107 Achieved by EM EM LEM Hardware requirements 50 physical qubits. 2-qubit gate fidelity 99.9%. Existing circuit execution rates. 50-100 physical qubits. Higher circuit execution rates, and/or higher 2-qubit gate infidelity 99.95 −99.99%. 2,000-10,000 physical qubits. 100 logical qubits. 2-qubit gate fidelity 99.9%.",
        "metadata": {
            "author": "",
            "keywords": [
                "Achieved",
                "LEM",
                "Hardware",
                "qubits",
                "gate",
                "physical",
                "Milestone",
                "requirements",
                "rates",
                "fidelity"
            ]
        }
    },
    {
        "id": "17ac8f83-1a1c-4a9d-9d40-918d07b54ccd",
        "title": "",
        "chunk_text": "Use cases Quantum many-body physics research + Quantum algorithm development + First industry relevant applications Volumes without EM/LEM V ∼103ϵ V ∼104ϵ V ∼(105 −107)ϵ 28 REFERENCES This manuscript makes a case for the importance of EM both as the enabler of the first useful QAs, as well as an accelerator of further finite QAs when combined with EC, once the latter becomes available. We believe these insights place EM as a crucial component towards truly useful quantum computation.",
        "metadata": {
            "author": "",
            "keywords": [
                "LEM",
                "REFERENCES",
                "Quantum",
                "Volumes",
                "QAs",
                "research",
                "development",
                "many-body",
                "physics",
                "algorithm"
            ]
        }
    },
    {
        "id": "c2545e60-cd9d-4849-8a17-ef989f42ecf5",
        "title": "",
        "chunk_text": "Acknowledgements We thank Ryan Babbush, Sergio Boixo, Jay Gambetta, David Hayes, Abhinav Kandala, Chris Langer, Sabrina Maniscalco, Tom O’Brien, John Preskill, Ittai Rubinstein, Thomas Schuster, Sarah Sheldon and Norman Yao for useful discussions and helpful comments. Note added Towards finalization of this manuscript, Reference [120] appeared on the arXiv, which provides a perspective on the role of EM in quantum computing.",
        "metadata": {
            "author": "",
            "keywords": [
                "Babbush",
                "Sergio",
                "Boixo",
                "Jay",
                "Gambetta",
                "David",
                "Hayes",
                "Abhinav",
                "Kandala",
                "Chris"
            ]
        }
    },
    {
        "id": "76ceefca-a645-46ad-8df6-c96e6db9facf",
        "title": "",
        "chunk_text": "The views and arguments presented in this reference are generally in line with the present paper, and we were pleased to see a consensus with the authors as to the important role of EM. Relative to Ref. [120], the present paper provides a more detailed and technical account to explain both the misconceptions and the justification of our predictions. We hope these expositions will be of use to the community. References [1] R. Takagi, S. Endo, S. Minagawa, and M.",
        "metadata": {
            "author": "",
            "keywords": [
                "present",
                "paper",
                "views",
                "arguments",
                "presented",
                "generally",
                "line",
                "pleased",
                "consensus",
                "authors"
            ]
        }
    },
    {
        "id": "fcdccf47-d57b-4a9e-9cf8-9c7226537919",
        "title": "",
        "chunk_text": "Gu, npj Quantum Information 8, 114 (2022). [2] R. Takagi, H. Tajima, and M. Gu, Phys. Rev. Lett. 131, 210602 (2023). [3] K. Tsubouchi, T. Sagawa, and N. Yoshioka, Phys. Rev. Lett. 131, 210601 (2023). [4] Y. Quek, D. Stilck França, S. Khatri, J. J. Meyer, and J. Eisert, Nature Physics 20, 1648 (2024). [5] T. Schuster, C. Yin, X. Gao, and N. Y. Yao, arXiv preprint arXiv:2407.12768 (2024). [6] E. Bernstein and U. Vazirani, SIAM Journal on Computing 26, 1411 (1997). [7] D. R.",
        "metadata": {
            "author": "",
            "keywords": [
                "Information",
                "Quantum",
                "Phys",
                "npj",
                "Rev",
                "Lett",
                "Tajima",
                "arXiv",
                "Sagawa",
                "Yoshioka"
            ]
        }
    },
    {
        "id": "26e40ff7-4007-416e-a812-39fd3404ea77",
        "title": "",
        "chunk_text": "Simon, SIAM Journal on Computing 26, 1474 (1997). [8] P. W. Shor, in Proceedings of the 35th Annual Symposium on Foundations of Computer Science (IEEE, 1994) pp. 124–134. [9] A. M. Steane, Physical Review Letters 77, 793 (1996). [10] P. W. Shor, Physical Review A 52, R2493 (1995). [11] D. Aharonov and M. Ben-Or, in Proceedings of the 29th Annual ACM Symposium on Theory of Computing (ACM, 1997) pp. 176–188. [12] A. Kitaev, Russian Mathematical Surveys 52, 1191 (1997). [13] E. Knill, R.",
        "metadata": {
            "author": "",
            "keywords": [
                "SIAM",
                "Journal",
                "Simon",
                "Shor",
                "Physical",
                "Computing",
                "Proceedings",
                "Annual",
                "Symposium",
                "Review"
            ]
        }
    },
    {
        "id": "b74072de-3f2a-4266-86ba-4b5d644bb87c",
        "title": "",
        "chunk_text": "Laflamme, and W. H. Zurek, Physical Review Letters 77, 411 (1996). [14] P. Aliferis, D. Gottesman, and J. Preskill, “Accuracy threshold for postselected quantum computation,” (2007), arXiv:quant-ph/0703264 [quant-ph] . [15] Google Quantum AI, “Google Quantum AI,” (2024), accessed: 2024-10-21. [16] IBM Quantum, “Ibm quantum technology,” (2024), accessed: 2024-10-21. [17] QuEra Computing, “Quera quantum error correction (qec),” (2024), accessed: 2024-10-21.",
        "metadata": {
            "author": "",
            "keywords": [
                "quantum",
                "Zurek",
                "Physical",
                "Letters",
                "Review",
                "accessed",
                "Google",
                "Laflamme",
                "IBM",
                "quant-ph"
            ]
        }
    },
    {
        "id": "311ee578-f23b-4d25-b0c4-f30dffa5b7dd",
        "title": "",
        "chunk_text": "[18] Quantinuum, “Quantinuum Unveils Accelerated Roadmap to Achieve Universal Fault-Tolerant Quantum Computing by 2030,” (2023), accessed: 2024-10-21. 29 REFERENCES [19] IonQ, “Ionq unveils accelerated roadmap and new technical milestones to propel quantum computing,” (2024), accessed: 2024-10-21. [20] IQM Quantum Computers, “Iqm quantum computers technology roadmap,” (2024), accessed: 2024- 10-21. [21] A. G. Fowler, M. Mariantoni, J. M. Martinis, and A. N.",
        "metadata": {
            "author": "",
            "keywords": [
                "Quantinuum",
                "accessed",
                "Accelerated",
                "IonQ",
                "REFERENCES",
                "Quantum",
                "Unveils",
                "Computing",
                "Achieve",
                "Universal"
            ]
        }
    },
    {
        "id": "bac7b33a-d4ee-42f5-9d20-dda47eaf714b",
        "title": "",
        "chunk_text": "Cleland, Physical Review A—Atomic, Molecular, and Optical Physics 86, 032324 (2012). [22] D. S. Wang, A. G. Fowler, and L. C. Hollenberg, Physical Review A—Atomic, Molecular, and Optical Physics 83, 020302 (2011). [23] Q. Xu, J. P. Bonilla Ataides, C. A. Pattison, N. Raveendran, D. Bluvstein, J. Wurtz, B. Vasić, M. D. Lukin, L. Jiang, and H. Zhou, Nature Physics , 1 (2024). [24] S. Bravyi, A. W. Cross, J. M. Gambetta, D. Maslov, P. Rall, and T. J.",
        "metadata": {
            "author": "",
            "keywords": [
                "Atomic",
                "Molecular",
                "Physics",
                "Physical",
                "Review",
                "Optical",
                "Cleland",
                "Wang",
                "Fowler",
                "Hollenberg"
            ]
        }
    },
    {
        "id": "d5f2e238-1180-4f2d-a1ca-53414190b26e",
        "title": "",
        "chunk_text": "Yoder, Nature 627, 78 (2024), accessed: 2024-10-21. [25] T. R. Scruby, T. Hillmann, and J. Roffe, arXiv preprint arXiv:2406.14445 (2024). [26] H. Yamasaki and M. Koashi, Nature Physics 20, 247 (2024). [27] H. Goto et al., Science Advances 10, eadp6388 (2024). [28] D. Bluvstein, S. J. Evered, A. A. Geim, S. H. Li, H. Zhou, T. Manovitz, S. Ebadi, M. Cain, M. Kalinowski, D. Hangleiter, et al., Nature 626, 58 (2024). [29] K. Mayer, C. Ryan-Anderson, N. Brown, E. Durso-Sabina, C. H. Baldwin, D.",
        "metadata": {
            "author": "",
            "keywords": [
                "Nature",
                "Yoder",
                "accessed",
                "Scruby",
                "Hillmann",
                "Roffe",
                "arXiv",
                "Koashi",
                "Physics",
                "Science"
            ]
        }
    },
    {
        "id": "b98744bd-9ebf-454f-98c4-323663949182",
        "title": "",
        "chunk_text": "Hayes, J. M. Dreiling, C. Foltz, J. P. Gaebler, T. M. Gatterman, et al., arXiv preprint arXiv:2404.08616 (2024). [30] M. da Silva, C. Ryan-Anderson, J. Bello-Rivas, A. Chernoguzov, J. Dreiling, C. Foltz, F. Frachon, J. Gaebler, T. Gatterman, L. Grans-Samuelsson, et al., arXiv preprint arXiv:2404.02280 . [31] B. W. Reichardt, D. Aasen, R. Chao, A. Chernoguzov, W. van Dam, J. P. Gaebler, D. Gresh, D. Lucchetti, M. Mills, S. A. Moses, et al., arXiv preprint arXiv:2409.04628 (2024). [32] R.",
        "metadata": {
            "author": "",
            "keywords": [
                "arXiv",
                "Gaebler",
                "Foltz",
                "Dreiling",
                "Gatterman",
                "preprint",
                "Chernoguzov",
                "Hayes",
                "Silva",
                "Frachon"
            ]
        }
    },
    {
        "id": "13cb8665-b024-47e6-9ba0-e460e837c78b",
        "title": "",
        "chunk_text": "Acharya, L. Aghababaie-Beni, I. Aleiner, T. I. Andersen, M. Ansmann, F. Arute, K. Arya, A. Asfaw, N. Astrakhantsev, J. Atalaya, et al., arXiv preprint arXiv:2408.13687 (2024). [33] H. Putterman, K. Noh, C. T. Hann, G. S. MacCabe, S. Aghaeimeibodi, R. N. Patel, M. Lee, W. M. Jones, H. Moradinejad, R. Rodriguez, et al., arXiv preprint arXiv:2409.13025 (2024). [34] F. Arute, K. Arya, R. Babbush, et al., Nature 574, 505 (2019). [35] Y. Wu, W.-S. Bao, S. Cao, F. Chen, M.-C. Chen, X. Chen, T.-H.",
        "metadata": {
            "author": "",
            "keywords": [
                "Aleiner",
                "Andersen",
                "Ansmann",
                "Asfaw",
                "Astrakhantsev",
                "Atalaya",
                "arXiv",
                "Arya",
                "Chen",
                "Acharya"
            ]
        }
    },
    {
        "id": "55a840e9-eff0-45ea-a2ad-1446afa2ef34",
        "title": "",
        "chunk_text": "Chung, H. Deng, Y. Du, D. Fan, et al., Physical review letters 127, 180501 (2021). [36] J.-W. Pan, C.-Y. Lu, Y. He, et al., Science 370, 1460 (2020). [37] Q. Zhu, S. Cao, F. Chen, M.-C. Chen, X. Chen, T.-H. Chung, H. Deng, Y. Du, D. Fan, M. Gong, et al., Science bulletin 67, 240 (2022). [38] A. Morvan, B. Villalonga, X. Mi, S. Mandrà, A. Bengtsson, P. V. Klimov, Z. Chen, S. Hong, C. Erickson, I. K. Drozdov, et al., Nature 618, 56 (2024). [39] M. DeCross, R. Haghshenas, M. Liu, E. Rinaldi, J.",
        "metadata": {
            "author": "",
            "keywords": [
                "Physical",
                "Chen",
                "Deng",
                "Fan",
                "Science",
                "Chung",
                "letters",
                "review",
                "Nature",
                "Cao"
            ]
        }
    },
    {
        "id": "e6d8bb5e-1291-436c-9260-47eabec410f7",
        "title": "",
        "chunk_text": "Gray, Y. Alexeev, C. H. Baldwin, J. P. Bartolotta, M. Bohn, E. Chertkov, et al., arXiv preprint arXiv:2406.02501 (2024). 30 REFERENCES [40] S. Aaronson and S.-H. Hung, in Proceedings of the 55th Annual ACM Symposium on Theory of Computing, STOC 2023 (Association for Computing Machinery, New York, NY, USA, 2023) p. 933–944. [41] Z. Cai, R. Babbush, S. C. Benjamin, S. Endo, W. J. Huggins, Y. Li, J. R. McClean, and T. E. O’Brien, Rev. Mod. Phys. 95, 045005 (2023). [42] K. Temme, S. Bravyi, and J.",
        "metadata": {
            "author": "",
            "keywords": [
                "Alexeev",
                "Baldwin",
                "Bartolotta",
                "Bohn",
                "Chertkov",
                "arXiv",
                "Gray",
                "REFERENCES",
                "Computing",
                "STOC"
            ]
        }
    },
    {
        "id": "fea547bc-df40-49a6-ad0c-8edd94a26671",
        "title": "",
        "chunk_text": "M. Gambetta, Phys. Rev. Lett. 119, 180509 (2017). [43] Y. Li and S. C. Benjamin, Physical Review X 7, 021050 (2017). [44] S. Endo, S. C. Benjamin, and Y. Li, Phys. Rev. X 8, 031027 (2018). [45] A. Mari, N. Shammah, and W. J. Zeng, Phys. Rev. A 104, 052607 (2021). [46] Z. Cai, npj Quantum Information 7, 80 (2021). [47] S. N. Filippov, S. Maniscalco, and G. García-Pérez, arXiv preprint arXiv:2403.13542 (2024). [48] Y. Kim, A. Eddins, S. Anand, K. X. Wei, E. Van Den Berg, S. Rosenblatt, H.",
        "metadata": {
            "author": "",
            "keywords": [
                "Phys",
                "Gambetta",
                "Rev",
                "Benjamin",
                "Physical",
                "arXiv",
                "Review",
                "Lett",
                "Shammah",
                "Zeng"
            ]
        }
    },
    {
        "id": "30ce2d6d-5e1d-4ed8-b086-e5f4a82d1e5d",
        "title": "",
        "chunk_text": "Nayfeh, Y. Wu, M. Zaletel, K. Temme, et al., Nature 618, 500 (2023). [49] K. Shinjo, K. Seki, T. Shirakawa, R.-Y. Sun, and S. Yunoki, arXiv preprint arXiv:2403.16718 (2024). [50] H. Yu, Y. Zhao, and T.-C. Wei, Physical Review Research 5, 013183 (2023). [51] X. Mi, A. Michailidis, S. Shabani, K. Miao, P. Klimov, J. Lloyd, E. Rosenberg, R. Acharya, I. Aleiner, T. Andersen, et al., Science 383, 1332 (2024). [52] G. Gyawali, T. Cochran, Y. Lensky, E. Rosenberg, A. H. Karamlou, K. Kechedzhi, J.",
        "metadata": {
            "author": "",
            "keywords": [
                "Nature",
                "Zaletel",
                "Temme",
                "Nayfeh",
                "Rosenberg",
                "Seki",
                "Shirakawa",
                "Sun",
                "Yunoki",
                "arXiv"
            ]
        }
    },
    {
        "id": "5cf968e1-9bb4-46f9-bf1c-2e9b5551106b",
        "title": "",
        "chunk_text": "Berndtsson, T. Westerhout, A. Asfaw, D. Abanin, et al., arXiv preprint arXiv:2410.06557 (2024). [53] M. Iqbal, A. Lyons, C. F. B. Lo, N. Tantivasadakarn, J. Dreiling, C. Foltz, T. M. Gatterman, D. Gresh, N. Hewitt, C. A. Holliman, et al., arXiv preprint arXiv:2411.04185 (2024). [54] G. Greene-Diniz, C. N. Self, M. Krompiec, L. Coopmans, M. Benedetti, D. M. Ramo, and M. Rosenkranz, arXiv preprint arXiv:2409.15908 (2024). [55] J.-S. Chen, E. Nielsen, M. Ebert, V. Inlek, K. Wright, V. Chaplin, A.",
        "metadata": {
            "author": "",
            "keywords": [
                "arXiv",
                "Westerhout",
                "Asfaw",
                "Abanin",
                "preprint",
                "Berndtsson",
                "Lyons",
                "Tantivasadakarn",
                "Dreiling",
                "Foltz"
            ]
        }
    },
    {
        "id": "061a12d6-2a34-4a14-ba05-c47b7d1b94b4",
        "title": "",
        "chunk_text": "Maksymov, E. Páez, A. Poudel, P. Maunz, et al., Quantum 8, 1516 (2024). [56] Riverlane, “Quantum error correction report 2024,” (2024), accessed: 2025-03-10. [57] J. Preskill, “Beyond nisq: The megaquop machine,” (2024), keynote address at the Q2B 2024 Conference, Silicon Valley. [58] D. W. Berry, R. S. T. Oliver, L. M. D. Ashley, and D. M. W. P. Brown, “Quantum algorithm zoo,” https://quantumalgorithmzoo.org/ (2020), accessed: 2025-02-16. [59] S. Lloyd, Science 273, 1073 (1996). [60] P.",
        "metadata": {
            "author": "",
            "keywords": [
                "Quantum",
                "Páez",
                "Poudel",
                "Maunz",
                "Maksymov",
                "accessed",
                "Riverlane",
                "Conference",
                "Silicon",
                "Valley"
            ]
        }
    },
    {
        "id": "388edca6-921a-4570-a215-97221ed40562",
        "title": "",
        "chunk_text": "Singkanipa, V. Kasatkin, Z. Zhou, G. Quiroz, and D. Lidar, Quant-Ph (2025). [61] I. L. Markov, A. Fatima, S. V. Isakov, and S. Boixo, arXiv preprint arXiv:1807.10749 (2018). [62] A. M. Dalzell, A. W. Harrow, D. E. Koh, and R. L. La Placa, Quantum 4, 264 (2020). [63] T. Ayral, P. Besserve, D. Lacroix, and E. A. R. Guzman, The European Physical Journal A 59, 227 (2023). 31 REFERENCES [64] I. Corporation, arXiv preprint arXiv:2001.10554 (2020), accessed: 2025-02-24. [65] A. P. Lund, M. J.",
        "metadata": {
            "author": "",
            "keywords": [
                "Kasatkin",
                "Zhou",
                "Quiroz",
                "Lidar",
                "Singkanipa",
                "Quant-Ph",
                "arXiv",
                "preprint",
                "Markov",
                "Fatima"
            ]
        }
    },
    {
        "id": "b50cb9b7-af0e-4d89-bc49-a561af19654d",
        "title": "",
        "chunk_text": "Bremner, and T. C. Ralph, njp quantum information 3 (2017). [66] Z. Brakerski, P. F. Christiano, U. Mahadev, U. V. Vazirani, and T. Vidick, in 59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018, Paris, France, October 7-9, 2018, edited by M. Thorup (IEEE Computer Society, 2018) pp. 320–331. [67] K. Liu and Z. Cai, arXiv preprint arXiv:2502.11285 (2025). [68] Qedma Quantum Computing, To appear (2025). [69] J.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ralph",
                "Bremner",
                "IEEE",
                "njp",
                "information",
                "Computer",
                "FOCS",
                "Paris",
                "France",
                "quantum"
            ]
        }
    },
    {
        "id": "a748da81-83a3-4f68-81dd-58d2e3ad71db",
        "title": "",
        "chunk_text": "Preskill, “Introduction to quantum computation and information,” (World Scientific, 1998) Chap. FAULT-TOLERANT QUANTUM COMPUTATION, pp. 213–269. [70] M. Ben-Or, D. Gottesman, and A. Hassidim, “Quantum refrigerator,” (2013), arXiv:1301.1995 [quant-ph] . [71] Y. Xiong, D. Chandra, S. X. Ng, and L. Hanzo, IEEE Access 8, 228967 (2020). [72] S. Ferracin, A. Hashim, J.-L. Ville, R. Naik, A. Carignan-Dugas, H. Qassim, A. Morvan, D. I. Santiago, I. Siddiqi, and J. J. Wallman, Quantum 8, 1410 (2024).",
        "metadata": {
            "author": "",
            "keywords": [
                "Chap",
                "Introduction",
                "World",
                "Scientific",
                "quantum",
                "computation",
                "Preskill",
                "information",
                "Gottesman",
                "Hassidim"
            ]
        }
    },
    {
        "id": "fbb85a89-0224-4bba-a112-29f22db7895e",
        "title": "",
        "chunk_text": "[73] E. Van Den Berg, Z. K. Minev, A. Kandala, and K. Temme, Nature physics 19, 1116 (2023). [74] E. Granet and H. Dreyer, arXiv preprint arXiv:2409.04254 (2024). [75] M. C. Tran, K. Sharma, and K. Temme, arXiv preprint arXiv:2303.06496 (2023). [76] A. Eddins, M. C. Tran, and P. Rall, arXiv preprint arXiv:2409.04401 (2024). [77] M. Kliesch and I. Roth, PRX Quantum 2, 010201 (2021). [78] D. Aharonov, M. Ben-Or, R. Impagliazzo, and N.",
        "metadata": {
            "author": "",
            "keywords": [
                "arXiv",
                "Temme",
                "preprint",
                "Tran",
                "Berg",
                "Minev",
                "Kandala",
                "Nature",
                "Den",
                "Dreyer"
            ]
        }
    },
    {
        "id": "9a8bca44-bebd-4227-8c0a-76c8ed4c1185",
        "title": "",
        "chunk_text": "Nisan, “Limitations of noisy reversible computation,” (1996), arXiv:quant-ph/9611028 [quant-ph] . [79] X. Gao and L. Duan, “Efficient classical simulation of noisy quantum computation,” (2018), arXiv:1810.03176 [quant-ph] . [80] A. Deshpande, P. Niroula, O. Shtanko, A. V. Gorshkov, B. Fefferman, and M. J. Gullans, PRX Quantum 3 (2022), 10.1103/prxquantum.3.040329. [81] M. J. Kastoryano and K.",
        "metadata": {
            "author": "",
            "keywords": [
                "quant-ph",
                "arXiv",
                "Limitations",
                "Nisan",
                "computation",
                "noisy",
                "quantum",
                "Duan",
                "Efficient",
                "reversible"
            ]
        }
    },
    {
        "id": "74fb9b40-49b4-4c09-b1c0-34c4d29c61a1",
        "title": "",
        "chunk_text": "Temme, Journal of Mathematical Physics 54, 052202 (2013), https://pubs.aip.org/aip/jmp/article-pdf/doi/10.1063/1.4804995/13369764/052202_1_online.pdf . [82] D. C. McKay, I. Hincks, E. J. Pritchett, M. Carroll, L. C. Govia, and S. T. Merkel, arXiv preprint arXiv:2311.05933 (2023). [83] D. Shepherd and M. J. Bremner, Proc. R. Soc. A 465, 1413 (2009). [84] M. J. Bremner and R. J. D. Shepherd, Proc. R. Soc. A 467, 459 (2011). [85] M. J. Bremner, D. Shepherd, and A. Montanaro, Phys. Rev. Lett.",
        "metadata": {
            "author": "",
            "keywords": [
                "Journal",
                "Physics",
                "Mathematical",
                "Proc",
                "Bremner",
                "Temme",
                "Soc",
                "Shepherd",
                "Hincks",
                "Pritchett"
            ]
        }
    },
    {
        "id": "4aeb68ef-122f-4788-a969-d52f07984daf",
        "title": "",
        "chunk_text": "117 (2016). [86] M. J. Bremner, A. Montanaro, and D. Shepherd, Quantum 1 (2017). [87] T. Bergamaschi, C.-F. Chen, and Y. Liu, in 65th IEEE Annual Symposium on Foundations of Computer Science, FOCS (IEEE Computer Society, 2024). [88] D. Aharonov, X. Gao, Z. Landau, Y. Liu, and U. Vazirani, arXiv preprint arXiv:2211.03999 (2022). 32 REFERENCES [89] C. Löschnauer, J. M. Toba, A. Hughes, S. King, M. Weber, R. Srinivas, R. Matt, R. Nourshargh, D. Allcock, C.",
        "metadata": {
            "author": "",
            "keywords": [
                "Liu",
                "IEEE",
                "Quantum",
                "Computer",
                "FOCS",
                "Bremner",
                "Montanaro",
                "Shepherd",
                "REFERENCES",
                "Chen"
            ]
        }
    },
    {
        "id": "fb34ff86-203f-46c9-b13a-5d00e6a02526",
        "title": "",
        "chunk_text": "Ballance, et al., arXiv preprint arXiv:2407.07694 (2024). [90] S. McArdle, S. Endo, A. Aspuru-Guzik, S. C. Benjamin, and X. Yuan, Reviews of Modern Physics 92, 015003 (2020), arXiv:1808.10402 . [91] S. Filippov, M. Leahy, M. A. Rossi, and G. García-Pérez, arXiv preprint arXiv:2307.11740 (2023). [92] N. Lindner and S. Yunoki, “Q2b24 tokyo | pushing forward for quantum advantage with error mitigation and hpc,” (2024), accessed: 2025-03-10. [93] B. Fuller, M. C. Tran, D. Lykov, C. Johnson, M.",
        "metadata": {
            "author": "",
            "keywords": [
                "arXiv",
                "Ballance",
                "preprint",
                "Endo",
                "Benjamin",
                "Yuan",
                "Reviews",
                "Physics",
                "Leahy",
                "Rossi"
            ]
        }
    },
    {
        "id": "f3f2c951-025a-4364-8978-acba01ce9763",
        "title": "",
        "chunk_text": "Rossmannek, K. X. Wei, A. He, Y. Kim, D. Vu, K. Sharma, et al., arXiv preprint arXiv:2502.01897 (2025). [94] TOP500 Authors, “Top500 november 2024 list,” https://top500.org/lists/top500/2024/11/ (2024), accessed: 2024-12-10. [95] B. Fang, M. Y. Özkaya, A. Li, Ü. V. Çatalyürek, and S. Krishnamoorthy, in 2022 IEEE International Conference on Cluster Computing (CLUSTER) (IEEE, 2022) pp. 289–300. [96] A. Nahum, S. Vijay, and J. Haah, Phys. Rev. X 8, 021014 (2018). [97] M. Larocca, S. Thanasilp, S.",
        "metadata": {
            "author": "",
            "keywords": [
                "Wei",
                "Kim",
                "Sharma",
                "Rossmannek",
                "arXiv",
                "Authors",
                "IEEE",
                "preprint",
                "Cluster",
                "november"
            ]
        }
    },
    {
        "id": "a9a5584f-25c3-4d11-9e4b-72508bd35b0b",
        "title": "",
        "chunk_text": "Wang, K. Sharma, J. Biamonte, P. J. Coles, L. Cincio, J. R. McClean, Z. Holmes, and M. Cerezo, arXiv preprint arXiv:2405.00781 (2024). [98] K. Kechedzhi, S. V. Isakov, S. Mandrà, B. Villalonga, X. Mi, S. Boixo, and V. Smelyanskiy, Future Generation Computer Systems 153, 431 (2024). [99] M. Vallero, F. Vella, and P. Rech, arXiv preprint arXiv:2401.06188 (2024). [100] F. Pan and P. Zhang, Phys. Rev. Lett. 128, 030501 (2022). [101] I. L. Markov and Y. Shi, SIAM Journal on Computing 38, 963 (2008).",
        "metadata": {
            "author": "",
            "keywords": [
                "Sharma",
                "Biamonte",
                "Coles",
                "Cincio",
                "Holmes",
                "Cerezo",
                "arXiv",
                "Wang",
                "McClean",
                "preprint"
            ]
        }
    },
    {
        "id": "14a3f8be-e061-401a-a4f1-8bbcbc8db4b5",
        "title": "",
        "chunk_text": "[102] J. Gray and S. Kourtis, Quantum 5, 410 (2021). [103] G. Vidal, Phys. Rev. Lett. 91, 147902 (2003). [104] J. Tindall, M. Fishman, E. M. Stoudenmire, and D. Sels, PRX Quantum 5, 010308 (2024). [105] A. Nahum, J. Ruhman, S. Vijay, and J. Haah, Phys. Rev. X 7, 031016 (2017). [106] S. Bravyi, D. Browne, P. Calpin, E. Campbell, D. Gosset, and M. Howard, Quantum 3, 181 (2019). [107] O. Reardon-Smith, M. Oszmaniec, and K. Korzekwa, Quantum 8, 1549 (2024). [108] Y. Zhou, E. M. Stoudenmire, and X.",
        "metadata": {
            "author": "",
            "keywords": [
                "Quantum",
                "Phys",
                "Stoudenmire",
                "Kourtis",
                "Rev",
                "Fishman",
                "Sels",
                "PRX",
                "Gray",
                "Ruhman"
            ]
        }
    },
    {
        "id": "3a84931a-6073-4a0c-b781-aa6fdfc13d5c",
        "title": "",
        "chunk_text": "Waintal, Phys. Rev. X 10, 041038 (2020). [109] Y. Suzuki, S. Endo, K. Fujii, and Y. Tokunaga, PRX Quantum 3, 010345 (2022). [110] C. Piveteau, D. Sutter, S. Bravyi, J. M. Gambetta, and K. Temme, Phys. Rev. Lett. 127, 200505 (2021). [111] M. Lostaglio and A. Ciani, Phys. Rev. Lett. 127, 200506 (2021). [112] Y. Xiong, D. Chandra, S. X. Ng, and L. Hanzo, IEEE Access 8, 228967 (2020). [113] K. Tsubouchi, Y. Mitsuhashi, K. Sharma, and N. Yoshioka, arXiv preprint arXiv:2405.07720 (2024).",
        "metadata": {
            "author": "",
            "keywords": [
                "Phys",
                "Rev",
                "Waintal",
                "Lett",
                "Endo",
                "Fujii",
                "Tokunaga",
                "PRX",
                "Quantum",
                "arXiv"
            ]
        }
    },
    {
        "id": "2e4bd1a3-03ae-46f4-ac3f-8ee037257247",
        "title": "",
        "chunk_text": "33 A APPENDIX [114] A. Zhang, H. Xie, Y. Gao, J.-N. Yang, Z. Bao, Z. Zhu, J. Chen, N. Wang, C. Zhang, J. Zhong, et al., arXiv preprint arXiv:2501.09079 (2025). [115] Qedma Quantum Computing, To appear (2025). [116] B. W. Reichardt, Quantum Science and Technology 6, 015007 (2020). [117] S. C. Smith, B. J. Brown, and S. D. Bartlett, Communications Physics 7, 386 (2024). [118] P. Prabhu and B. W. Reichardt, Phys. Rev. A 110, 012419 (2024). [119] L. Clinton, T. Cubitt, B. Flynn, F. M. Gambetta, J.",
        "metadata": {
            "author": "",
            "keywords": [
                "APPENDIX",
                "Zhang",
                "Reichardt",
                "Quantum",
                "Xie",
                "Gao",
                "Yang",
                "Bao",
                "Zhu",
                "Chen"
            ]
        }
    },
    {
        "id": "4a3a4de9-cd87-4714-9438-3f006e1469bd",
        "title": "",
        "chunk_text": "Klassen, A. Montanaro, S. Piddock, R. A. Santos, and E. Sheridan, Nature Communications 15, 211 (2024). [120] Z. Zimborás, B. Koczor, Z. Holmes, E.-M. Borrelli, A. Gilyén, H.-Y. Huang, Z. Cai, A. Acín, L. Aolita, L. Banchi, et al., arXiv preprint arXiv:2501.05694 (2025).",
        "metadata": {
            "author": "",
            "keywords": [
                "Montanaro",
                "Piddock",
                "Santos",
                "Sheridan",
                "Nature",
                "Communications",
                "Klassen",
                "Koczor",
                "Holmes",
                "Borrelli"
            ]
        }
    },
    {
        "id": "8b6b248a-590d-4160-bfa1-9388b1a855e2",
        "title": "",
        "chunk_text": "A Appendix A.1 Known lower bounds on sampling overhead of general EM methods References [3, 4] demonstrated the existence of circuits for which the sample complexity of any EM protocol must be exponential in the total circuit volume nD/2, and not only in D. The construction is based on random circuits made of layers sampled from an n-qubit unitary 2-design.",
        "metadata": {
            "author": "",
            "keywords": [
                "Appendix",
                "References",
                "demonstrated",
                "lower",
                "bounds",
                "sampling",
                "overhead",
                "general",
                "methods",
                "existence"
            ]
        }
    },
    {
        "id": "45cc7023-2383-4fdf-a6ea-6f7a02ae0fb7",
        "title": "",
        "chunk_text": "Assuming a fixed local error channel after each layer, and averaging over the above ensemble of circuits, leads to a twirling of the local error channel into an n-qubit depolarizing channel. The latter leads to a decay of the output state towards the maximally mixed state, with a decay constant that is proportional to the total circuit volume (this prototypical example is discussed in more detail in Sec. 4.1).",
        "metadata": {
            "author": "",
            "keywords": [
                "channel",
                "error",
                "local",
                "leads",
                "Assuming",
                "layer",
                "fixed",
                "averaging",
                "ensemble",
                "twirling"
            ]
        }
    },
    {
        "id": "e746b0b1-083f-4e21-8213-68bacbb9a551",
        "title": "",
        "chunk_text": "Accordingly, there exists an individual circuit in the ensemble which exhibits the same decay. Reference [4] showed that the same conclusion holds when constructing the above 2-designs from 2-qubit Clifford gates followed by a local error channel. By transpiling the above construction to QPUs with the connectivity of a d-dimensional lattice, Ref.",
        "metadata": {
            "author": "",
            "keywords": [
                "decay",
                "exists",
                "individual",
                "circuit",
                "ensemble",
                "exhibits",
                "Clifford",
                "Ref",
                "Reference",
                "showed"
            ]
        }
    },
    {
        "id": "c414426e-6e54-45f4-9622-109d79fd3ef7",
        "title": "",
        "chunk_text": "[4] further showed compelling evidence that, for the above circuit ensemble, it is the active volume (or ‘light cone’) that controls the sampling overhead of EM, as opposed to the total circuit volume. Technically, the bounds in Ref. [4] are phrased in terms of the total volume, but are only valid for D large enough such that all n qubits can be entangled by the circuit, given the restricted circuit connectivity.",
        "metadata": {
            "author": "",
            "keywords": [
                "volume",
                "circuit",
                "ensemble",
                "light",
                "cone’",
                "total",
                "showed",
                "compelling",
                "evidence",
                "active"
            ]
        }
    },
    {
        "id": "fdb79938-2d23-4e9d-9ce5-0d389ecc756d",
        "title": "",
        "chunk_text": "A.2 Deducing exponential lower bounds on number of shots, from classical simulation of noisy circuits Here we turn back to the first question discussed in Section 4, and ask whether the results of Ref. [5] can be used to deduce the lower bound of Eq. (6) for generic EM protocols. As mentioned above, there are specific counter examples in which this bound does not hold [74]; however, one might expect the lower bound to still hold generically.",
        "metadata": {
            "author": "",
            "keywords": [
                "Deducing",
                "Section",
                "Ref",
                "lower",
                "bound",
                "shots",
                "exponential",
                "number",
                "classical",
                "simulation"
            ]
        }
    },
    {
        "id": "0852dd3e-89d5-4f0e-a690-29c9886dd6c5",
        "title": "",
        "chunk_text": "We focus on classically-hard circuit families In (see Definition 3.1) and assume that classical simulation algorithms for the given class of ideal circuits and observables In must scale as Ω(2n). We consider any EM protocol, which for any circuit and observable (C, O) ∈In, achieves an accuracy ϵ on average over computational input states. Using Eq. (8), we can then reverse the logic of Corollary 1, yielding a lower bound M = Ω(e˜Ω(γ2n)) for the shot overhead.",
        "metadata": {
            "author": "",
            "keywords": [
                "Definition",
                "circuit",
                "focus",
                "classically-hard",
                "families",
                "assume",
                "classical",
                "simulation",
                "algorithms",
                "class"
            ]
        }
    },
    {
        "id": "4aca4ba1-561f-4b64-b48b-7905e6e6dc46",
        "title": "",
        "chunk_text": "This may be compared with the known result M = Ω(eΩ(γD)) for any EM protocol, applied to any (C, O), that achieves accuracy ϵ on a fixed input state [1–4]. In cases where n /∈O(D) the bound obtained from Ref. [5] is stronger (asymptotically, though with a weaker constant γ2 as opposed to γ). For example, in 2d circuits where n ∼D2, the sampling overhead scales exponentially in D2 rather than in D. Note that this still does not guarantee an overhead exponential in V as in Eq.",
        "metadata": {
            "author": "",
            "keywords": [
                "protocol",
                "applied",
                "state",
                "compared",
                "result",
                "achieves",
                "accuracy",
                "fixed",
                "input",
                "Ref"
            ]
        }
    },
    {
        "id": "6359e0b0-f6d8-43bc-bf38-0e48f8e28d22",
        "title": "",
        "chunk_text": "(3) (which is, e.g., ∼D3 in the 2d circuit case). Interestingly, this still leaves open the 34 A APPENDIX following possibility (suggested in Ref. [74]): there may be a family with fine tuned input states, which are on one hand classically hard (namely their classical simulation must scale as Ω(2n)) for which there exists an EM protocol that exhibits a sampling overhead which is exponential only in D (and not in n) when restricted to those fine tuned input states.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "case",
                "states",
                "Ref",
                "tuned",
                "input",
                "APPENDIX",
                "fine",
                "Interestingly",
                "possibility"
            ]
        }
    },
    {
        "id": "20f399e1-6943-49a1-9552-e175665464c7",
        "title": "",
        "chunk_text": "Such cases, if they exist, would lead to a quasi-polynomial QA (in between polynomial and exponential), such that, e.g., for 2d circuits, Tc = Ω(2n), but TEM = O(eγ√n). A.3 Calculating V = V (n, v) for the HPC run time plot in Fig. 2 The plots of the classical run time estimations for Fig. 2 require calculating the active volume V as a function of n and the operator spread velocity v. We detail here how these calculations are done to derive Eq. (20). Let us start with the simple case: v = 1.",
        "metadata": {
            "author": "",
            "keywords": [
                "TEM",
                "Fig.",
                "circuits",
                "exist",
                "exponential",
                "Calculating",
                "run",
                "time",
                "lead",
                "quasi-polynomial"
            ]
        }
    },
    {
        "id": "ff148259-b9a6-481b-98b9-e95b50d8371f",
        "title": "",
        "chunk_text": "Here, the active volume corresponds to the “naïve” light-cone that is determined by the circuit connectivity. In such cases the qubit support of this lightcone (which is the number of active qubits), is n = \u0000 2 d · D \u0001d. The 2/d factor accounts for the fact that each layer extends the support only in one of the d dimensions, but in both the positive and negative directions along that dimension. Similarly, for a general v ∈[0, 1], the qubit support is given by n = \u00122v d D \u0013d .",
        "metadata": {
            "author": "",
            "keywords": [
                "support",
                "active",
                "naïve",
                "light-cone",
                "connectivity",
                "qubit",
                "volume",
                "corresponds",
                "determined",
                "circuit"
            ]
        }
    },
    {
        "id": "1c0f5ea4-70bb-44f6-89ba-0e611c6416dd",
        "title": "",
        "chunk_text": "(23) Once n is fixed, the active volume is given by the volume of a (d + 1)-dimensional pyramid with base area n and height D. We additionally divide by a factor of 2, to take into account that a dense layer on m qubits involves m/2 2-qubit gates. We thus derive: V = nD 2(d + 1) = cd 4vn1/cd, (24) where cd = d/(d + 1). This relation can be easily inverted to give n as a function of V : n = (4vV/cd)cd . (25) 35",
        "metadata": {
            "author": "",
            "keywords": [
                "volume",
                "fixed",
                "dimensional",
                "active",
                "pyramid",
                "base",
                "area",
                "height",
                "gates",
                "additionally"
            ]
        }
    }
]